---
sidebar_position: 7
---

# JavaScript Foundations: From Confusion to Confidence

This is your complete foundation. Every concept here builds the muscle memory you need for React. No shortcuts, no skipping ahead. Just deep understanding, step by step.

## What You'll Build

By the end of this page, you'll have real mastery of JavaScript fundamentals. Not just syntax—actual understanding of how and why code works. This is the foundation that makes React feel natural instead of magical.

---

## Section 1: Getting Started

### What is JavaScript? (In Plain English)

JavaScript is the language that makes websites interactive. Think of HTML as the skeleton (structure), CSS as the skin (appearance), and JavaScript as the muscles and brain (behavior).

When you click a button and something happens, that's JavaScript. When a form validates your input before you submit it, that's JavaScript. When content updates without refreshing the page, that's JavaScript.

**Simple truth:** JavaScript is just a set of instructions you write to tell the browser what to do.

### How Code Runs (Your First Experiment)

Open your browser's DevTools:
- **Chrome/Edge:** Press `F12` or `Cmd+Option+J` (Mac) / `Ctrl+Shift+J` (Windows)
- **Firefox:** Press `F12` or `Cmd+Option+K` (Mac) / `Ctrl+Shift+K` (Windows)

Go to the **Console** tab. This is your playground.

Type this and press Enter:

```javascript
console.log("Hello, world!");
```

**What just happened?**
- `console.log()` is a built-in function that prints to the console
- The browser read your code, executed it, and showed you the result
- This is how all JavaScript runs: line by line, top to bottom

### Your First Challenge: Type and See!

Don't copy-paste. **Type each one** and predict what will happen BEFORE you press Enter:

```javascript
2 + 2
"Hello" + " " + "World"
10 * 5
100 / 4
```

**Why typing matters:** Your fingers need to learn the patterns. Typing builds muscle memory. Copying doesn't.

---

## Section 2: Variables In Depth

### The Box Analogy

A variable is like a labeled box where you store a value. The label is the variable name, and what's inside the box is the value.

```javascript
let count = 0; // 'count' is a box labeled "count". Inside it: the number 0
const birthday = "May 3"; // 'birthday' is a box labeled "birthday". Inside: "May 3"
```

### Three Ways to Declare Variables

```javascript
let age = 25;        // ✅ Can be changed later
const name = "Sarah"; // ✅ Cannot be changed (constant)
var score = 100;     // ❌ Old way, avoid it
```

**Real analogy:**
- `let` = a box you can empty and refill
- `const` = a box that's sealed shut after you put something in
- `var` = outdated box with confusing rules (ignore it)

### When to Use Which?

```javascript
// Use const for values that never change
const PI = 3.14159;
const DAYS_IN_WEEK = 7;
const API_URL = "https://api.example.com";

// Use let for values that DO change
let userInput = "";        // Will change as user types
let count = 0;            // Will change when counting
let isLoggedIn = false;   // Will change on login
```

**Rule of thumb:** Start with `const`. Only use `let` if you know the value will change.

### Naming Rules and Best Practices

```javascript
// ✅ Good variable names (clear, descriptive)
let userName = "Alice";
let totalPrice = 99.99;
let isActive = true;

// ❌ Bad variable names (unclear, cryptic)
let x = "Alice";      // What is 'x'?
let tp = 99.99;       // What is 'tp'?
let flag = true;      // Flag for what?

// Rules:
// 1. Start with letter, $, or _
let name = "valid";
let $price = "valid";
let _count = "valid";

// 2. Can't start with number
// let 1st = "invalid"; // ❌ Error!

// 3. Can't use reserved words
// let const = 5; // ❌ Error!
// let function = "test"; // ❌ Error!

// 4. Case sensitive
let age = 25;
let Age = 30;  // Different variable!
```

**Naming convention:** Use `camelCase` for variable names:
- First word lowercase
- Capitalize first letter of each subsequent word
- Examples: `firstName`, `totalCartValue`, `isUserLoggedIn`

### Mutability and Scope

**Mutability = Can it change?**

```javascript
let count = 0;
count = 1;     // ✅ Works - let is mutable
count = 2;     // ✅ Works

const MAX = 100;
// MAX = 200;  // ❌ Error: Cannot reassign const

// BUT CAREFUL: const objects/arrays CAN change internally
const user = { name: "Alice" };
user.name = "Bob";  // ✅ Works - we're not reassigning 'user', just changing what's inside
// user = {};       // ❌ Error - can't reassign
```

**Scope = Where can you access the variable?**

```javascript
// Global scope - accessible everywhere
const globalVar = "I'm everywhere!";

function myFunction() {
  // Function scope - only accessible inside this function
  const functionVar = "I only exist here";
  console.log(globalVar);    // ✅ Works
  console.log(functionVar);  // ✅ Works
}

// console.log(functionVar); // ❌ Error: functionVar is not defined

if (true) {
  // Block scope - only accessible inside this block
  const blockVar = "I only exist in this if block";
  console.log(blockVar); // ✅ Works
}

// console.log(blockVar); // ❌ Error: blockVar is not defined
```

**Visual representation:**

```
Global Scope
│
├── Variable: globalVar ✅ accessible everywhere
│
└── Function Scope
    │
    ├── Variable: functionVar ✅ accessible only in function
    │
    └── Block Scope (if statement)
        │
        └── Variable: blockVar ✅ accessible only in block
```

### Real Bug Scenario: Forgetting let/const

```javascript
// ❌ WRONG: Forgot to declare with let/const
function updateCount() {
  count = 5;  // Creates global variable by accident!
}

updateCount();
console.log(count); // 5 - Oops, leaked into global scope

// ✅ CORRECT: Properly declared
function updateCount() {
  let count = 5;  // Stays in function scope
}

updateCount();
// console.log(count); // ❌ Error: count is not defined (as it should be!)
```

### Mini Exercise: Variables

**Challenge 1:** Declare a constant for your birth year and a let variable for your current age.

```javascript
// Your code here:


```

<details>
<summary>Solution</summary>

```javascript
const birthYear = 1995;
let currentAge = 30;
```
</details>

**Challenge 2:** Find the bug in this code:

```javascript
const score = 0;
score = 10;
console.log(score);
```

<details>
<summary>Solution</summary>

```javascript
// Bug: Can't reassign const
// Fix: Use let instead
let score = 0;
score = 10;
console.log(score); // 10
```
</details>

---

## Section 3: Types & Type Conversion

### The Six Primitive Types

```javascript
// 1. Number - any number (integer or decimal)
let age = 25;
let price = 19.99;
let negative = -10;

// 2. String - text in quotes
let name = "Alice";
let message = 'Hello';
let template = `Hi, ${name}`; // Template literal

// 3. Boolean - true or false
let isActive = true;
let isComplete = false;

// 4. Undefined - variable declared but not assigned
let result;
console.log(result); // undefined

// 5. Null - intentional absence of value
let data = null; // "I deliberately have no value"

// 6. Symbol - unique identifier (advanced, ignore for now)
```

### The typeof Operator

```javascript
console.log(typeof 42);          // "number"
console.log(typeof "hello");     // "string"
console.log(typeof true);        // "boolean"
console.log(typeof undefined);   // "undefined"
console.log(typeof null);        // "object" ⚠️ This is a bug in JavaScript!
console.log(typeof {});          // "object"
console.log(typeof []);          // "object" ⚠️ Arrays are objects
```

**Why typeof matters:** You need to check types to prevent bugs.

```javascript
function double(num) {
  if (typeof num !== "number") {
    return "Error: not a number!";
  }
  return num * 2;
}

console.log(double(5));      // 10
console.log(double("5"));    // "Error: not a number!"
```

### Type Conversion: The Source of Many Bugs

**String + Number = String (Concatenation)**

```javascript
let n = "5";
let m = 1;
console.log(n + m);           // "51" ❌ String concatenation, not math!
console.log(Number(n) + m);   // 6 ✅ Converted to number first
```

**Common conversions:**

```javascript
// String → Number
let str = "42";
let num1 = Number(str);      // 42
let num2 = parseInt(str);    // 42 (integer only)
let num3 = parseFloat("3.14"); // 3.14 (decimals allowed)
let num4 = +"42";            // 42 (shorthand, but less clear)

// Number → String
let count = 100;
let str1 = String(count);    // "100"
let str2 = count.toString(); // "100"
let str3 = "" + count;       // "100" (works but unclear)

// Boolean → Number
let bool = true;
console.log(Number(bool));   // 1
console.log(Number(false));  // 0

// Anything → Boolean
console.log(Boolean(1));      // true
console.log(Boolean(0));      // false
console.log(Boolean("hi"));   // true
console.log(Boolean(""));     // false
```

### Common Pitfalls

```javascript
// Pitfall 1: String math
console.log("5" + 1);    // "51" (concatenation)
console.log("5" - 1);    // 4 (subtraction forces number conversion)
console.log("5" * 2);    // 10 (multiplication forces number conversion)

// Pitfall 2: NaN (Not a Number)
console.log(Number("hello")); // NaN
console.log(NaN + 5);         // NaN (NaN infects everything)

// Check for NaN:
console.log(isNaN("hello"));  // true
console.log(isNaN(42));       // false

// Pitfall 3: Truthy/Falsy (covered more later)
console.log(Boolean(0));      // false
console.log(Boolean(""));     // false
console.log(Boolean(null));   // false
console.log(Boolean(undefined)); // false
```

### When You Have to Care in Real Code

```javascript
// Example: User input is ALWAYS a string
// <input type="text" id="age" />

const userInput = "25";  // From input field

// ❌ WRONG: Trying to use it as a number
const nextYear = userInput + 1;
console.log(nextYear); // "251" - Bug!

// ✅ CORRECT: Convert first
const age = Number(userInput);
const nextYearAge = age + 1;
console.log(nextYearAge); // 26 - Correct!
```

### Mini Exercise: Types

**Predict the output:**

```javascript
console.log("10" - "5");
console.log("10" + "5");
console.log(typeof null);
console.log(Boolean("false"));
```

<details>
<summary>Answers</summary>

```javascript
console.log("10" - "5");        // 5 (subtraction converts to numbers)
console.log("10" + "5");        // "105" (concatenation)
console.log(typeof null);       // "object" (JavaScript bug)
console.log(Boolean("false"));  // true (non-empty string is truthy)
```
</details>

---

## Section 4: Operators and Expressions

### Assignment Operators

```javascript
let x = 5;     // = assigns value

// Shorthand operators
x += 3;  // Same as: x = x + 3  → x is now 8
x -= 2;  // Same as: x = x - 2  → x is now 6
x *= 4;  // Same as: x = x * 4  → x is now 24
x /= 3;  // Same as: x = x / 3  → x is now 8
x %= 5;  // Same as: x = x % 5  → x is now 3 (remainder)
```

### Arithmetic Operators

```javascript
console.log(10 + 5);   // 15 (addition)
console.log(10 - 5);   // 5 (subtraction)
console.log(10 * 5);   // 50 (multiplication)
console.log(10 / 5);   // 2 (division)
console.log(10 % 3);   // 1 (remainder/modulo)
console.log(2 ** 3);   // 8 (exponentiation: 2³)

// Increment and decrement
let count = 0;
count++;        // Same as: count = count + 1
console.log(count); // 1

count--;        // Same as: count = count - 1
console.log(count); // 0
```

**Modulo (%) - Real use case:**

```javascript
// Check if number is even or odd
function isEven(num) {
  return num % 2 === 0;
}

console.log(isEven(4));  // true
console.log(isEven(7));  // false

// Cycle through array indices
const colors = ["red", "green", "blue"];
let index = 5;
console.log(colors[index % colors.length]); // "green" (index 2)
```

### Comparison Operators: == vs ===

**The golden rule: ALWAYS use ===**

```javascript
// === strict equality (checks value AND type)
console.log(5 === 5);        // true
console.log(5 === "5");      // false (different types)
console.log(true === 1);     // false (different types)

// == loose equality (converts types, then compares)
console.log(5 == "5");       // true ⚠️ Converts "5" to 5 first
console.log(true == 1);      // true ⚠️ Converts true to 1 first
console.log(null == undefined); // true ⚠️ Weird!

// !== strict inequality
console.log(5 !== "5");      // true (different types)

// != loose inequality (avoid!)
console.log(5 != "5");       // false (converts types)
```

**Why === is safer:**

```javascript
const userInput = "0";

// ❌ WRONG: Using ==
if (userInput == false) {
  console.log("This runs!"); // Bug: "0" == false is true
}

// ✅ CORRECT: Using ===
if (userInput === false) {
  console.log("This never runs"); // Correct: "0" !== false
}
```

**Other comparison operators:**

```javascript
console.log(5 > 3);    // true
console.log(5 < 3);    // false
console.log(5 >= 5);   // true
console.log(5 <= 4);   // false
```

### Logical Operators

**&& (AND) - Both must be true**

```javascript
const age = 25;
const hasLicense = true;

if (age >= 18 && hasLicense) {
  console.log("Can drive"); // Both conditions must be true
}

// Truth table for &&
console.log(true && true);    // true
console.log(true && false);   // false
console.log(false && true);   // false
console.log(false && false);  // false
```

**|| (OR) - At least one must be true**

```javascript
const isWeekend = true;
const isHoliday = false;

if (isWeekend || isHoliday) {
  console.log("No work!"); // At least one must be true
}

// Truth table for ||
console.log(true || true);    // true
console.log(true || false);   // true
console.log(false || true);   // true
console.log(false || false);  // false
```

**! (NOT) - Flips the value**

```javascript
const isLoggedIn = false;

if (!isLoggedIn) {
  console.log("Please log in"); // ! flips false to true
}

console.log(!true);   // false
console.log(!false);  // true
console.log(!!true);  // true (double negation)
```

**Real decision examples:**

```javascript
// Example 1: Login check
const username = "alice";
const password = "secret";

if (username === "alice" && password === "secret") {
  console.log("Login successful!");
} else {
  console.log("Invalid credentials");
}

// Example 2: Access control
const age = 17;
const hasParentPermission = true;

if (age >= 18 || hasParentPermission) {
  console.log("Access granted");
} else {
  console.log("Access denied");
}

// Example 3: Form validation
const email = "user@example.com";
const agreedToTerms = true;

if (email.includes("@") && agreedToTerms) {
  console.log("Form is valid");
} else {
  console.log("Please fill all required fields");
}
```

### Mini Quiz: Operators

**Predict the output:**

```javascript
console.log(10 % 3);
console.log("5" === 5);
console.log(true && false);
console.log(5 > 3 || 2 > 10);
console.log(!"hello");
```

<details>
<summary>Answers</summary>

```javascript
console.log(10 % 3);            // 1 (remainder)
console.log("5" === 5);         // false (different types)
console.log(true && false);     // false (AND requires both true)
console.log(5 > 3 || 2 > 10);   // true (OR needs one true)
console.log(!"hello");          // false (non-empty string is truthy, ! flips it)
```
</details>

---

Due to length, I'll continue this in a second file. Let me create part 1 now.

## Section 5: Control Flow (Decision Making)

### if/else: Making Decisions

```javascript
// Basic if statement
const age = 18;

if (age >= 18) {
  console.log("You can vote!");
}

// if/else
const score = 75;

if (score >= 60) {
  console.log("You passed!");
} else {
  console.log("You failed.");
}

// if/else if/else
const grade = 85;

if (grade >= 90) {
  console.log("A - Excellent!");
} else if (grade >= 80) {
  console.log("B - Good job!");
} else if (grade >= 70) {
  console.log("C - Average");
} else if (grade >= 60) {
  console.log("D - Needs improvement");
} else {
  console.log("F - Failed");
}
```

### Truthy vs Falsy Values

**Falsy values (only 6 in JavaScript):**

```javascript
// These all evaluate to false in conditions:
if (false) { }        // false
if (0) { }            // 0
if ("") { }           // empty string
if (null) { }         // null
if (undefined) { }    // undefined
if (NaN) { }          // NaN

// Everything else is truthy!
```

**Truthy examples:**

```javascript
if (true) { }         // true
if (1) { }            // any non-zero number
if ("hello") { }      // any non-empty string
if ("0") { }          // "0" is truthy! (it's a string)
if ("false") { }      // "false" is truthy! (it's a string)
if ([]) { }           // empty array is truthy
if ({}) { }           // empty object is truthy
if (function() {}) { }// function is truthy
```

**Real usage:**

```javascript
// Check if user entered something
const userInput = ""; // From form field

if (userInput) {
  console.log("You entered:", userInput);
} else {
  console.log("Please enter something!");
}

// Check if array has items
const items = [];

if (items.length) {
  console.log("Cart has", items.length, "items");
} else {
  console.log("Cart is empty");
}
```

### switch Statement

**When to use:** Multiple conditions checking the same variable.

```javascript
// ❌ Messy if/else chain
const day = "Monday";

if (day === "Monday") {
  console.log("Start of work week");
} else if (day === "Friday") {
  console.log("Almost weekend!");
} else if (day === "Saturday" || day === "Sunday") {
  console.log("Weekend!");
} else {
  console.log("Midweek");
}

// ✅ Cleaner with switch
switch (day) {
  case "Monday":
    console.log("Start of work week");
    break; // Important! Stops checking other cases
  case "Friday":
    console.log("Almost weekend!");
    break;
  case "Saturday":
  case "Sunday":
    console.log("Weekend!");
    break;
  default: // Like 'else' - runs if no case matches
    console.log("Midweek");
}
```

**Why break matters:**

```javascript
const num = 1;

switch (num) {
  case 1:
    console.log("One");
    // Forgot break! Falls through to next case
  case 2:
    console.log("Two");
    break;
}
// Output: "One" then "Two" - Bug!
```

### Practical Examples

**Example 1: Grading system**

```javascript
function getLetterGrade(score) {
  if (score < 0 || score > 100) {
    return "Invalid score";
  }
  
  if (score >= 90) return "A";
  if (score >= 80) return "B";
  if (score >= 70) return "C";
  if (score >= 60) return "D";
  return "F";
}

console.log(getLetterGrade(85)); // "B"
console.log(getLetterGrade(59)); // "F"
```

**Example 2: Login validation**

```javascript
function validateLogin(username, password) {
  // Guard clauses - check problems first
  if (!username) {
    return "Username is required";
  }
  
  if (username.length < 3) {
    return "Username must be at least 3 characters";
  }
  
  if (!password) {
    return "Password is required";
  }
  
  if (password.length < 8) {
    return "Password must be at least 8 characters";
  }
  
  // All checks passed
  return "Valid credentials";
}

console.log(validateLogin("", "password")); // "Username is required"
console.log(validateLogin("ab", "password")); // "Username must be at least 3 characters"
console.log(validateLogin("alice", "pass")); // "Password must be at least 8 characters"
console.log(validateLogin("alice", "password123")); // "Valid credentials"
```

**Example 3: Age verification**

```javascript
function canAccessContent(age, hasParentConsent) {
  if (age >= 18) {
    return { allowed: true, reason: "User is an adult" };
  }
  
  if (age >= 13 && hasParentConsent) {
    return { allowed: true, reason: "Parent consent provided" };
  }
  
  return { allowed: false, reason: "Too young or no parent consent" };
}

console.log(canAccessContent(20, false)); 
// { allowed: true, reason: "User is an adult" }

console.log(canAccessContent(15, true)); 
// { allowed: true, reason: "Parent consent provided" }

console.log(canAccessContent(15, false)); 
// { allowed: false, reason: "Too young or no parent consent" }
```

### Mini Exercise: Control Flow

**Challenge:** Write a function that takes a temperature and returns:
- "Freezing" if below 32°F
- "Cold" if 32-50°F
- "Mild" if 51-70°F
- "Warm" if 71-85°F
- "Hot" if above 85°F

<details>
<summary>Solution</summary>

```javascript
function describeTemperature(temp) {
  if (temp < 32) return "Freezing";
  if (temp <= 50) return "Cold";
  if (temp <= 70) return "Mild";
  if (temp <= 85) return "Warm";
  return "Hot";
}

console.log(describeTemperature(25)); // "Freezing"
console.log(describeTemperature(65)); // "Mild"
console.log(describeTemperature(90)); // "Hot"
```
</details>

---

## Section 6: Functions—All the Ways

### Three Ways to Write Functions

```javascript
// 1. Function Declaration
function greet(name) {
  return "Hello, " + name;
}

// 2. Function Expression
const greet = function(name) {
  return "Hello, " + name;
};

// 3. Arrow Function (Modern, most common in React)
const greet = (name) => {
  return "Hello, " + name;
};

// Arrow function shorthand (when returning one thing)
const greet = (name) => "Hello, " + name;

// All three work the same way:
console.log(greet("Alice")); // "Hello, Alice"
```

**When to use each:**

```javascript
// Function declaration - hoisted (can call before definition)
sayHi(); // Works!
function sayHi() {
  console.log("Hi!");
}

// Function expression - NOT hoisted
// greet(); // ❌ Error: Cannot access before initialization
const greet = function() {
  console.log("Hello!");
};

// Arrow function - shortest syntax, best for callbacks
const numbers = [1, 2, 3];
numbers.map(n => n * 2); // Clean and concise
```

### Parameters vs Arguments

```javascript
// Parameters = placeholders when you DEFINE the function
function add(a, b) { // 'a' and 'b' are parameters
  return a + b;
}

// Arguments = actual values when you CALL the function
add(5, 3); // 5 and 3 are arguments
```

### Default Values

```javascript
// Old way (before ES6)
function greet(name) {
  name = name || "friend"; // Use "friend" if name is falsy
  return "Hello, " + name;
}

// Modern way (ES6+)
function greet(name = "friend") {
  return "Hello, " + name;
}

console.log(greet("Alice")); // "Hello, Alice"
console.log(greet());        // "Hello, friend"

// Multiple defaults
function createUser(name = "Anonymous", age = 0, role = "user") {
  return { name, age, role };
}

console.log(createUser()); 
// { name: "Anonymous", age: 0, role: "user" }

console.log(createUser("Bob", 25)); 
// { name: "Bob", age: 25, role: "user" }
```

### Rest Parameters

```javascript
// Collect all arguments into an array
function sum(...numbers) { // ...numbers is the rest parameter
  let total = 0;
  for (let num of numbers) {
    total += num;
  }
  return total;
}

console.log(sum(1, 2));          // 3
console.log(sum(1, 2, 3, 4, 5)); // 15

// Mix regular params with rest
function introduce(greeting, ...names) {
  return greeting + " " + names.join(" and ");
}

console.log(introduce("Hello", "Alice", "Bob", "Carol"));
// "Hello Alice and Bob and Carol"
```

### Return Values vs Side Effects

```javascript
// Return value - gives something back
function add(a, b) {
  return a + b; // Returns the result
}

const result = add(2, 3);
console.log(result); // 5

// Side effect - does something (logs, modifies external state)
function logMessage(msg) {
  console.log(msg); // Side effect: prints to console
  // No return statement = returns undefined
}

const result2 = logMessage("Hello");
console.log(result2); // undefined

// Can have both
function addAndLog(a, b) {
  const sum = a + b;
  console.log("Sum is:", sum); // Side effect
  return sum;                  // Return value
}
```

### Pure vs Impure Functions

**Pure function = same input always gives same output, no side effects**

```javascript
// ✅ Pure function
function add(a, b) {
  return a + b; // Only depends on inputs, no side effects
}

console.log(add(2, 3)); // 5
console.log(add(2, 3)); // 5 - Always the same!

// ✅ Pure function
function getFullName(firstName, lastName) {
  return firstName + " " + lastName;
}

// ❌ Impure function (depends on external state)
let total = 0;
function addToTotal(num) {
  total += num; // Modifies external variable
  return total;
}

console.log(addToTotal(5)); // 5
console.log(addToTotal(5)); // 10 - Different result with same input!

// ❌ Impure function (side effect)
function logAndReturn(value) {
  console.log(value); // Side effect
  return value;
}
```

**Why pure functions matter:** Easier to test, debug, and reason about. React loves pure functions!

### Passing Functions as Arguments (Callbacks)

```javascript
// Functions are values - you can pass them around
function sayHello() {
  console.log("Hello!");
}

function executeFunction(fn) {
  fn(); // Call the function that was passed in
}

executeFunction(sayHello); // "Hello!"

// Inline function
executeFunction(function() {
  console.log("Goodbye!");
}); // "Goodbye!"

// Arrow function (most common)
executeFunction(() => {
  console.log("Hi there!");
}); // "Hi there!"
```

**Real example: Array methods**

```javascript
const numbers = [1, 2, 3, 4, 5];

// map takes a callback function
const doubled = numbers.map(function(num) {
  return num * 2;
});

// Cleaner with arrow function
const doubled = numbers.map(num => num * 2);

console.log(doubled); // [2, 4, 6, 8, 10]
```

### How This Connects to React

```javascript
// React components are just functions!
function Welcome() {
  return <h1>Hello!</h1>;
}

// Event handlers are callbacks
function Button() {
  const handleClick = () => {
    console.log("Button clicked!");
  };
  
  return <button onClick={handleClick}>Click me</button>;
  //                       ^^^ Passing function as prop
}

// Array methods everywhere
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

### Mini Exercise: Functions

**Challenge 1:** Write a function that takes a name and returns a greeting. If no name is provided, greet "friend".

<details>
<summary>Solution</summary>

```javascript
const greet = (name = "friend") => `Hello, ${name}!`;

console.log(greet("Alice")); // "Hello, Alice!"
console.log(greet());        // "Hello, friend!"
```
</details>

**Challenge 2:** Write a pure function that takes an array of numbers and returns a new array with each number tripled.

<details>
<summary>Solution</summary>

```javascript
const triple = (numbers) => numbers.map(n => n * 3);

console.log(triple([1, 2, 3])); // [3, 6, 9]
```
</details>

---

## Section 7: Arrays Deep Dive

### Creating and Modifying Arrays

```javascript
// Creating arrays
const empty = [];
const numbers = [1, 2, 3, 4, 5];
const mixed = [1, "hello", true, null];

// Accessing elements (zero-indexed!)
console.log(numbers[0]); // 1 (first element)
console.log(numbers[4]); // 5 (last element)
console.log(numbers[5]); // undefined (doesn't exist)

// Length
console.log(numbers.length); // 5

// Last element
console.log(numbers[numbers.length - 1]); // 5
```

### Adding and Removing Elements

```javascript
const fruits = ["apple", "banana"];

// push - add to end
fruits.push("orange");
console.log(fruits); // ["apple", "banana", "orange"]

// pop - remove from end
const last = fruits.pop();
console.log(last);   // "orange"
console.log(fruits); // ["apple", "banana"]

// unshift - add to beginning
fruits.unshift("mango");
console.log(fruits); // ["mango", "apple", "banana"]

// shift - remove from beginning
const first = fruits.shift();
console.log(first);  // "mango"
console.log(fruits); // ["apple", "banana"]
```

**Visual representation:**

```
unshift    push
   ↓         ↓
["apple", "banana"]
   ↑         ↑
 shift     pop
```

### Array Methods - The Power Tools

**includes() - Check if value exists**

```javascript
const fruits = ["apple", "banana", "orange"];

console.log(fruits.includes("banana")); // true
console.log(fruits.includes("grape"));  // false
```

**indexOf() - Find position of value**

```javascript
const fruits = ["apple", "banana", "orange", "banana"];

console.log(fruits.indexOf("banana")); // 1 (first occurrence)
console.log(fruits.indexOf("grape"));  // -1 (not found)
```

**map() - Transform every element**

```javascript
const numbers = [1, 2, 3, 4, 5];

// Double every number
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// Step-by-step what map does:
// 1. Take first number (1) → multiply by 2 → add 2 to new array
// 2. Take second number (2) → multiply by 2 → add 4 to new array
// 3. Take third number (3) → multiply by 2 → add 6 to new array
// ... and so on

// Original array unchanged
console.log(numbers); // [1, 2, 3, 4, 5]

// Real example: Format names
const names = ["alice", "bob", "carol"];
const capitalized = names.map(name => {
  return name[0].toUpperCase() + name.slice(1);
});
console.log(capitalized); // ["Alice", "Bob", "Carol"]
```

**filter() - Keep only elements that pass a test**

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Keep only even numbers
const evens = numbers.filter(num => num % 2 === 0);
console.log(evens); // [2, 4, 6, 8, 10]

// Keep only numbers greater than 5
const bigNumbers = numbers.filter(num => num > 5);
console.log(bigNumbers); // [6, 7, 8, 9, 10]

// Real example: Filter active users
const users = [
  { name: "Alice", active: true },
  { name: "Bob", active: false },
  { name: "Carol", active: true }
];

const activeUsers = users.filter(user => user.active);
console.log(activeUsers);
// [{ name: "Alice", active: true }, { name: "Carol", active: true }]
```

**find() - Get first element that matches**

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Carol" }
];

const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: "Bob" }

const notFound = users.find(u => u.id === 99);
console.log(notFound); // undefined
```

**reduce() - Combine all elements into one value**

```javascript
const numbers = [1, 2, 3, 4, 5];

// Sum all numbers
const sum = numbers.reduce((total, num) => {
  return total + num;
}, 0); // 0 is the starting value
console.log(sum); // 15

// Step-by-step what happens:
// total=0, num=1 → return 0+1=1
// total=1, num=2 → return 1+2=3
// total=3, num=3 → return 3+3=6
// total=6, num=4 → return 6+4=10
// total=10, num=5 → return 10+5=15

// Product of all numbers
const product = numbers.reduce((total, num) => total * num, 1);
console.log(product); // 120

// Real example: Count items
const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];
const count = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
console.log(count); // { apple: 3, banana: 2, orange: 1 }
```

**forEach() - Do something with each element**

```javascript
const numbers = [1, 2, 3];

// forEach doesn't return anything - just runs code
numbers.forEach(num => {
  console.log(num * 2);
});
// Prints: 2, 4, 6

// When to use forEach vs map:
// map → when you want a new array
// forEach → when you just want to do something (side effects)
```

### Chaining Methods

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Get doubled values of even numbers greater than 5
const result = numbers
  .filter(n => n > 5)        // [6, 7, 8, 9, 10]
  .filter(n => n % 2 === 0)  // [6, 8, 10]
  .map(n => n * 2);          // [12, 16, 20]

console.log(result); // [12, 16, 20]
```

### Loops: Different Ways to Iterate

```javascript
const fruits = ["apple", "banana", "orange"];

// 1. for loop (traditional)
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}

// 2. for...of (modern, cleaner)
for (let fruit of fruits) {
  console.log(fruit);
}

// 3. forEach method
fruits.forEach(fruit => {
  console.log(fruit);
});

// When to use each:
// - for loop: when you need the index
// - for...of: when you just need the values
// - forEach: when working with array methods (map, filter, etc.)
```

### Practical Patterns

**Shopping cart total:**

```javascript
const cart = [
  { name: "Laptop", price: 999 },
  { name: "Mouse", price: 25 },
  { name: "Keyboard", price: 75 }
];

const total = cart.reduce((sum, item) => sum + item.price, 0);
console.log(total); // 1099
```

**Todo list filtering:**

```javascript
const todos = [
  { id: 1, text: "Learn JS", done: true },
  { id: 2, text: "Learn React", done: false },
  { id: 3, text: "Build project", done: false }
];

const pending = todos.filter(todo => !todo.done);
console.log(pending);
// [{ id: 2, text: "Learn React", done: false }, 
//  { id: 3, text: "Build project", done: false }]
```

**Leaderboard (sorting):**

```javascript
const scores = [
  { name: "Alice", score: 95 },
  { name: "Bob", score: 87 },
  { name: "Carol", score: 92 }
];

// Sort by score (highest first)
const leaderboard = scores.sort((a, b) => b.score - a.score);
console.log(leaderboard);
// [{ name: "Alice", score: 95 },
//  { name: "Carol", score: 92 },
//  { name: "Bob", score: 87 }]
```

### Common Bugs

**Off-by-one errors:**

```javascript
const numbers = [1, 2, 3, 4, 5];

// ❌ WRONG: Tries to access index 5 (doesn't exist)
for (let i = 0; i <= numbers.length; i++) {
  console.log(numbers[i]); // Last one is undefined
}

// ✅ CORRECT: Stops before length
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]);
}
```

**Mutating arrays accidentally:**

```javascript
const original = [1, 2, 3];

// ❌ WRONG: push/pop/shift/unshift mutate the original
const modified = original;
modified.push(4);
console.log(original); // [1, 2, 3, 4] - Oops!

// ✅ CORRECT: Create new array
const modified = [...original, 4]; // Spread operator
console.log(original); // [1, 2, 3] - Unchanged
console.log(modified); // [1, 2, 3, 4]
```

### Mini Exercise: Arrays

**Challenge:** Given an array of numbers, return a new array with only the odd numbers, doubled.

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// Your code here
```

<details>
<summary>Solution</summary>

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const result = numbers
  .filter(n => n % 2 !== 0) // Keep odd numbers
  .map(n => n * 2);          // Double them

console.log(result); // [2, 6, 10, 14, 18]
```
</details>

---

## Section 8: Objects Explained Visually

### What is an Object?

Think of an object as a container that holds related information. It's like a real-world object with properties.

**Real-world analogy:**
```
A person has:
- name: "Alice"
- age: 25
- email: "alice@example.com"

A car has:
- brand: "Toyota"
- model: "Camry"
- year: 2023
```

### Creating Objects

```javascript
// Object literal (most common way)
const person = {
  name: "Alice",      // property: value
  age: 25,
  email: "alice@example.com"
};

// Empty object
const emptyObj = {};

// Adding properties later
emptyObj.name = "Bob";
emptyObj.age = 30;
```

### Accessing Properties: Two Ways

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com",
  "favorite color": "blue" // Property with space needs quotes
};

// 1. Dot notation (most common)
console.log(user.name);  // "Alice"
console.log(user.age);   // 25

// 2. Bracket notation (when property name has spaces or is in a variable)
console.log(user["favorite color"]); // "blue"
console.log(user["name"]);           // "Alice"

// Using bracket notation with variables
const prop = "email";
console.log(user[prop]); // "alice@example.com"
```

**When to use which:**
- **Dot notation:** Clean and simple, use when possible
- **Bracket notation:** When property has spaces, special chars, or is in a variable

### Modifying Objects

```javascript
const user = {
  name: "Alice",
  age: 25
};

// Update existing property
user.age = 26;
console.log(user.age); // 26

// Add new property
user.email = "alice@example.com";
console.log(user);
// { name: "Alice", age: 26, email: "alice@example.com" }

// Delete property
delete user.age;
console.log(user);
// { name: "Alice", email: "alice@example.com" }
```

### Nested Objects (Objects inside Objects)

```javascript
const user = {
  name: "Alice",
  age: 25,
  address: {                    // Nested object
    street: "123 Main St",
    city: "San Francisco",
    state: "CA",
    zip: "94101"
  },
  preferences: {
    theme: "dark",
    notifications: true
  }
};

// Access nested properties
console.log(user.address.city);              // "San Francisco"
console.log(user.preferences.theme);         // "dark"

// Modify nested properties
user.address.city = "Los Angeles";
console.log(user.address.city);              // "Los Angeles"

// Add to nested object
user.address.country = "USA";
console.log(user.address.country);           // "USA"
```

**Visual representation:**
```
user
├── name: "Alice"
├── age: 25
├── address
│   ├── street: "123 Main St"
│   ├── city: "San Francisco"
│   ├── state: "CA"
│   └── zip: "94101"
└── preferences
    ├── theme: "dark"
    └── notifications: true
```

### Methods: Functions Inside Objects

```javascript
const calculator = {
  // Properties
  brand: "Casio",

  // Methods (functions as properties)
  add: function(a, b) {
    return a + b;
  },

  // Shorthand method syntax (modern)
  subtract(a, b) {
    return a - b;
  },

  // Arrow function method
  multiply: (a, b) => a * b
};

// Call methods
console.log(calculator.add(5, 3));      // 8
console.log(calculator.subtract(10, 4)); // 6
console.log(calculator.multiply(3, 7));  // 21
```

### The "this" Keyword

**"this" refers to the object the method belongs to**

```javascript
const person = {
  firstName: "Alice",
  lastName: "Johnson",
  age: 25,

  // Regular function - 'this' works correctly
  getFullName: function() {
    return this.firstName + " " + this.lastName;
    //     ^^^^ 'this' refers to 'person'
  },

  // Shorthand - 'this' works correctly
  greet() {
    return `Hi, I'm ${this.firstName} and I'm ${this.age} years old`;
  },

  // ⚠️ Arrow function - 'this' doesn't work as expected
  getBio: () => {
    // return this.firstName; // ❌ 'this' doesn't refer to person!
  }
};

console.log(person.getFullName()); // "Alice Johnson"
console.log(person.greet());       // "Hi, I'm Alice and I'm 25 years old"
```

**Important rule:** Use regular functions or shorthand for methods, NOT arrow functions!

### Checking if Property Exists

```javascript
const user = {
  name: "Alice",
  age: 25
};

// 1. in operator
console.log("name" in user);    // true
console.log("email" in user);   // false

// 2. hasOwnProperty method
console.log(user.hasOwnProperty("age"));    // true
console.log(user.hasOwnProperty("email"));  // false

// 3. Check for undefined (less reliable)
console.log(user.name !== undefined);  // true
console.log(user.email !== undefined); // false
```

### Object Methods (Built-in Helpers)

**Object.keys() - Get all property names**

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com"
};

const keys = Object.keys(user);
console.log(keys); // ["name", "age", "email"]

// Loop through keys
keys.forEach(key => {
  console.log(key, ":", user[key]);
});
// name : Alice
// age : 25
// email : alice@example.com
```

**Object.values() - Get all values**

```javascript
const scores = {
  math: 95,
  english: 88,
  science: 92
};

const values = Object.values(scores);
console.log(values); // [95, 88, 92]

// Calculate average
const average = values.reduce((sum, score) => sum + score, 0) / values.length;
console.log(average); // 91.67
```

**Object.entries() - Get key-value pairs**

```javascript
const user = {
  name: "Alice",
  age: 25,
  city: "SF"
};

const entries = Object.entries(user);
console.log(entries);
// [["name", "Alice"], ["age", 25], ["city", "SF"]]

// Loop with both key and value
entries.forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});
// name: Alice
// age: 25
// city: SF
```

### Copying Objects

**Shallow copy - copies top level only**

```javascript
const original = {
  name: "Alice",
  age: 25,
  address: {
    city: "SF"
  }
};

// Method 1: Spread operator (most common)
const copy1 = { ...original };

// Method 2: Object.assign()
const copy2 = Object.assign({}, original);

// Both work the same
copy1.name = "Bob";
console.log(original.name); // "Alice" - Unchanged ✓

// ⚠️ BUT nested objects are still referenced
copy1.address.city = "LA";
console.log(original.address.city); // "LA" - Changed! ⚠️
```

**Deep copy - copies everything (including nested objects)**

```javascript
const original = {
  name: "Alice",
  address: {
    city: "SF"
  }
};

// Deep copy using JSON (simple way, but has limitations)
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.address.city = "LA";
console.log(original.address.city); // "SF" - Unchanged ✓
```

### Object Destructuring

**Extract properties into variables**

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com",
  city: "SF"
};

// Old way
const name = user.name;
const age = user.age;

// ✅ Modern way (destructuring)
const { name, age, email } = user;
console.log(name);  // "Alice"
console.log(age);   // 25
console.log(email); // "alice@example.com"

// Rename while destructuring
const { name: userName, age: userAge } = user;
console.log(userName); // "Alice"
console.log(userAge);  // 25

// Default values
const { city, country = "USA" } = user;
console.log(city);    // "SF"
console.log(country); // "USA" (default, not in object)
```

**Nested destructuring:**

```javascript
const user = {
  name: "Alice",
  address: {
    city: "SF",
    state: "CA"
  }
};

// Extract nested properties
const { address: { city, state } } = user;
console.log(city);  // "SF"
console.log(state); // "CA"
```

**In function parameters:**

```javascript
// Instead of this:
function greetUser(user) {
  console.log(`Hello, ${user.name}! You are ${user.age} years old.`);
}

// Do this (destructure in parameters):
function greetUser({ name, age }) {
  console.log(`Hello, ${name}! You are ${age} years old.`);
}

const user = { name: "Alice", age: 25 };
greetUser(user); // "Hello, Alice! You are 25 years old."
```

### Arrays of Objects (Very Common in Real Apps)

```javascript
const users = [
  { id: 1, name: "Alice", age: 25, active: true },
  { id: 2, name: "Bob", age: 30, active: false },
  { id: 3, name: "Carol", age: 28, active: true }
];

// Find user by id
const user = users.find(u => u.id === 2);
console.log(user); // { id: 2, name: "Bob", age: 30, active: false }

// Get all active users
const activeUsers = users.filter(u => u.active);
console.log(activeUsers);
// [{ id: 1, name: "Alice", ... }, { id: 3, name: "Carol", ... }]

// Get just the names
const names = users.map(u => u.name);
console.log(names); // ["Alice", "Bob", "Carol"]

// Calculate average age
const avgAge = users.reduce((sum, u) => sum + u.age, 0) / users.length;
console.log(avgAge); // 27.67
```

### Practical Real-World Examples

**Example 1: User profile**

```javascript
const createUser = (name, email, age) => {
  return {
    name,                          // Shorthand: same as name: name
    email,                         // Shorthand: same as email: email
    age,
    createdAt: new Date(),
    isActive: true,

    // Methods
    getProfile() {
      return `${this.name} (${this.email})`;
    },

    deactivate() {
      this.isActive = false;
    }
  };
};

const user = createUser("Alice", "alice@example.com", 25);
console.log(user.getProfile()); // "Alice (alice@example.com)"
user.deactivate();
console.log(user.isActive); // false
```

**Example 2: Shopping cart**

```javascript
const cart = {
  items: [],

  addItem(product, quantity = 1) {
    this.items.push({ product, quantity });
  },

  removeItem(productId) {
    this.items = this.items.filter(item => item.product.id !== productId);
  },

  getTotal() {
    return this.items.reduce((total, item) => {
      return total + (item.product.price * item.quantity);
    }, 0);
  },

  getItemCount() {
    return this.items.reduce((count, item) => count + item.quantity, 0);
  }
};

// Use the cart
cart.addItem({ id: 1, name: "Laptop", price: 999 }, 1);
cart.addItem({ id: 2, name: "Mouse", price: 25 }, 2);

console.log(cart.getTotal());     // 1049
console.log(cart.getItemCount()); // 3

cart.removeItem(2);
console.log(cart.getTotal());     // 999
console.log(cart.getItemCount()); // 1
```

**Example 3: Todo list**

```javascript
const todoList = {
  todos: [],
  nextId: 1,

  addTodo(text) {
    this.todos.push({
      id: this.nextId++,
      text,
      completed: false,
      createdAt: new Date()
    });
  },

  toggleTodo(id) {
    const todo = this.todos.find(t => t.id === id);
    if (todo) {
      todo.completed = !todo.completed;
    }
  },

  deleteTodo(id) {
    this.todos = this.todos.filter(t => t.id !== id);
  },

  getCompleted() {
    return this.todos.filter(t => t.completed);
  },

  getPending() {
    return this.todos.filter(t => !t.completed);
  }
};

// Use the todo list
todoList.addTodo("Learn JavaScript");
todoList.addTodo("Learn React");
todoList.addTodo("Build a project");

console.log(todoList.todos.length); // 3

todoList.toggleTodo(1);
console.log(todoList.getCompleted()); // [{ id: 1, text: "Learn JavaScript", completed: true, ... }]
console.log(todoList.getPending());   // [{ id: 2, ... }, { id: 3, ... }]
```

### How Objects Connect to React

```javascript
// React component props are objects!
function UserCard(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>{props.email}</p>
    </div>
  );
}

// With destructuring (more common):
function UserCard({ name, email, age }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>{email}</p>
      <p>Age: {age}</p>
    </div>
  );
}

// State is often an object
const [user, setUser] = useState({
  name: "Alice",
  email: "alice@example.com"
});

// Update state object
setUser({ ...user, email: "newemail@example.com" });

// Mapping arrays of objects
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" }
];

return (
  <ul>
    {users.map(user => (
      <li key={user.id}>{user.name}</li>
    ))}
  </ul>
);
```

### Mini Exercise: Objects

**Challenge 1:** Create a book object with title, author, pages, and a method that returns a summary string.

<details>
<summary>Solution</summary>

```javascript
const book = {
  title: "The Great Gatsby",
  author: "F. Scott Fitzgerald",
  pages: 180,

  getSummary() {
    return `${this.title} by ${this.author}, ${this.pages} pages`;
  }
};

console.log(book.getSummary());
// "The Great Gatsby by F. Scott Fitzgerald, 180 pages"
```
</details>

**Challenge 2:** Given an array of products, return an array of just the product names where price is less than $50.

```javascript
const products = [
  { name: "Laptop", price: 999 },
  { name: "Mouse", price: 25 },
  { name: "Keyboard", price: 75 },
  { name: "USB Cable", price: 10 }
];

// Your code here
```

<details>
<summary>Solution</summary>

```javascript
const cheapProducts = products
  .filter(p => p.price < 50)
  .map(p => p.name);

console.log(cheapProducts); // ["Mouse", "USB Cable"]
```
</details>

---

## Section 9: Loops & Iteration

### The for Loop (Classic)

**Structure:**
```
for (initialization; condition; increment) {
  // code to run
}
```

**Basic example:**

```javascript
// Print numbers 0 to 4
for (let i = 0; i < 5; i++) {
  console.log(i);
}
// Output: 0, 1, 2, 3, 4

// What happens step-by-step:
// 1. let i = 0              → Initialize i
// 2. Check: is i < 5? (yes) → Run code, print 0
// 3. i++                    → i becomes 1
// 4. Check: is i < 5? (yes) → Run code, print 1
// 5. i++                    → i becomes 2
// ... continues until i = 5
// 6. Check: is i < 5? (no)  → Stop
```

**Loop through array:**

```javascript
const fruits = ["apple", "banana", "orange", "grape"];

for (let i = 0; i < fruits.length; i++) {
  console.log(i, fruits[i]);
}
// 0 "apple"
// 1 "banana"
// 2 "orange"
// 3 "grape"
```

**Loop backwards:**

```javascript
const numbers = [1, 2, 3, 4, 5];

for (let i = numbers.length - 1; i >= 0; i--) {
  console.log(numbers[i]);
}
// 5, 4, 3, 2, 1
```

**Loop with step:**

```javascript
// Count by 2s
for (let i = 0; i <= 10; i += 2) {
  console.log(i);
}
// 0, 2, 4, 6, 8, 10

// Every 3rd element
const letters = ["a", "b", "c", "d", "e", "f", "g", "h"];
for (let i = 0; i < letters.length; i += 3) {
  console.log(letters[i]);
}
// "a", "d", "g"
```

### The while Loop

**Runs while condition is true**

```javascript
let count = 0;

while (count < 5) {
  console.log(count);
  count++;  // ⚠️ Don't forget to increment!
}
// 0, 1, 2, 3, 4

// ⚠️ Infinite loop - NEVER do this:
// while (true) {
//   console.log("Forever!"); // Crashes browser!
// }
```

**Real use case: Unknown number of iterations**

```javascript
// Generate random numbers until we get one > 0.9
let randomNum;
let attempts = 0;

while (randomNum === undefined || randomNum <= 0.9) {
  randomNum = Math.random();
  attempts++;
  console.log(`Attempt ${attempts}: ${randomNum}`);
}

console.log(`Got ${randomNum} after ${attempts} attempts`);
```

### The do...while Loop

**Runs at least once, then checks condition**

```javascript
let num = 10;

do {
  console.log(num); // Runs once even though condition is false
  num++;
} while (num < 5);
// Output: 10

// Use case: Menu that runs at least once
let choice;
do {
  // choice = prompt("Enter 1, 2, or 3:");
  choice = "2"; // Simulated input
  console.log(`You chose: ${choice}`);
} while (choice !== "3");
```

### The for...of Loop (Modern, Cleaner)

**Best for iterating over arrays**

```javascript
const fruits = ["apple", "banana", "orange"];

// Old way
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}

// ✅ New way (cleaner)
for (let fruit of fruits) {
  console.log(fruit);
}
// "apple", "banana", "orange"

// Works with strings too
const word = "hello";
for (let char of word) {
  console.log(char);
}
// "h", "e", "l", "l", "o"
```

**When you need the index:**

```javascript
const fruits = ["apple", "banana", "orange"];

// Use entries() to get both index and value
for (let [index, fruit] of fruits.entries()) {
  console.log(index, fruit);
}
// 0 "apple"
// 1 "banana"
// 2 "orange"
```

### The for...in Loop (For Objects)

**Iterates over object keys**

```javascript
const person = {
  name: "Alice",
  age: 25,
  city: "SF"
};

for (let key in person) {
  console.log(key, ":", person[key]);
}
// name : Alice
// age : 25
// city : SF
```

**⚠️ Don't use for...in with arrays** (use for...of instead)

```javascript
const fruits = ["apple", "banana", "orange"];

// ❌ Don't do this
for (let index in fruits) {
  console.log(index); // "0", "1", "2" (strings, not numbers!)
}

// ✅ Do this
for (let fruit of fruits) {
  console.log(fruit);
}
```

### break and continue

**break - Exit loop immediately**

```javascript
// Stop when we find what we're looking for
const numbers = [1, 3, 5, 8, 10, 12];

for (let num of numbers) {
  if (num % 2 === 0) {
    console.log("Found first even number:", num);
    break; // Stop the loop
  }
}
// "Found first even number: 8"

// Without break, all evens would print
```

**continue - Skip to next iteration**

```javascript
// Skip odd numbers
for (let i = 1; i <= 10; i++) {
  if (i % 2 !== 0) {
    continue; // Skip rest of this iteration
  }
  console.log(i);
}
// 2, 4, 6, 8, 10

// Print all except "banana"
const fruits = ["apple", "banana", "orange", "grape"];
for (let fruit of fruits) {
  if (fruit === "banana") {
    continue; // Skip banana
  }
  console.log(fruit);
}
// "apple", "orange", "grape"
```

### Nested Loops

**Loop inside another loop**

```javascript
// Multiplication table
for (let i = 1; i <= 3; i++) {
  for (let j = 1; j <= 3; j++) {
    console.log(`${i} x ${j} = ${i * j}`);
  }
  console.log("---");
}
// 1 x 1 = 1
// 1 x 2 = 2
// 1 x 3 = 3
// ---
// 2 x 1 = 2
// 2 x 2 = 4
// 2 x 3 = 6
// ---
// 3 x 1 = 3
// 3 x 2 = 6
// 3 x 3 = 9
// ---

// 2D array (matrix)
const matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

for (let i = 0; i < matrix.length; i++) {
  for (let j = 0; j < matrix[i].length; j++) {
    console.log(`matrix[${i}][${j}] = ${matrix[i][j]}`);
  }
}
```

### Choosing the Right Loop

```javascript
const fruits = ["apple", "banana", "orange"];

// 1. Just need values? → for...of
for (let fruit of fruits) {
  console.log(fruit);
}

// 2. Need index? → traditional for loop
for (let i = 0; i < fruits.length; i++) {
  console.log(i, fruits[i]);
}

// 3. Need to transform array? → Array methods
const uppercase = fruits.map(f => f.toUpperCase());

// 4. Need to filter? → Array methods
const longNames = fruits.filter(f => f.length > 5);

// 5. Don't know how many iterations? → while
let found = false;
while (!found) {
  // ... search logic
}

// 6. Iterating object? → for...in or Object.keys()
const person = { name: "Alice", age: 25 };

for (let key in person) {
  console.log(key, person[key]);
}

// OR (more modern)
Object.keys(person).forEach(key => {
  console.log(key, person[key]);
});
```

### Practical Examples

**Example 1: Find in array (manual)**

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Carol" }
];

function findUserById(id) {
  for (let user of users) {
    if (user.id === id) {
      return user; // Return and exit immediately
    }
  }
  return null; // Not found
}

console.log(findUserById(2)); // { id: 2, name: "Bob" }
console.log(findUserById(99)); // null

// Note: In real code, use array.find() instead
const user = users.find(u => u.id === 2);
```

**Example 2: Build HTML from data**

```javascript
const products = [
  { id: 1, name: "Laptop", price: 999 },
  { id: 2, name: "Mouse", price: 25 },
  { id: 3, name: "Keyboard", price: 75 }
];

let html = "<ul>";
for (let product of products) {
  html += `<li>${product.name}: $${product.price}</li>`;
}
html += "</ul>";

console.log(html);
// <ul><li>Laptop: $999</li><li>Mouse: $25</li><li>Keyboard: $75</li></ul>
```

**Example 3: Validate all inputs**

```javascript
const formInputs = [
  { name: "username", value: "alice" },
  { name: "email", value: "" },  // Invalid: empty
  { name: "password", value: "123456" }
];

function validateForm(inputs) {
  const errors = [];

  for (let input of inputs) {
    if (!input.value || input.value.trim() === "") {
      errors.push(`${input.name} is required`);
    }
  }

  return errors.length === 0 ? "Valid" : errors;
}

console.log(validateForm(formInputs));
// ["email is required"]
```

**Example 4: Sum numbers in range**

```javascript
function sumRange(start, end) {
  let sum = 0;
  for (let i = start; i <= end; i++) {
    sum += i;
  }
  return sum;
}

console.log(sumRange(1, 5));   // 15 (1+2+3+4+5)
console.log(sumRange(10, 15)); // 75 (10+11+12+13+14+15)
```

### Common Mistakes

**Mistake 1: Infinite loop**

```javascript
// ❌ WRONG: Never increments
let i = 0;
while (i < 5) {
  console.log(i);
  // Forgot i++! Loops forever!
}

// ✅ CORRECT
let i = 0;
while (i < 5) {
  console.log(i);
  i++; // Don't forget this!
}
```

**Mistake 2: Off-by-one error**

```javascript
const arr = [1, 2, 3];

// ❌ WRONG: Tries to access arr[3] which doesn't exist
for (let i = 0; i <= arr.length; i++) {
  console.log(arr[i]); // Last one is undefined
}

// ✅ CORRECT: Stop before length
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

**Mistake 3: Modifying array while looping**

```javascript
const numbers = [1, 2, 3, 4, 5];

// ❌ WRONG: Don't modify array you're looping over
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 === 0) {
    numbers.splice(i, 1); // Removes element - messes up loop!
  }
}

// ✅ CORRECT: Use filter to create new array
const odds = numbers.filter(n => n % 2 !== 0);
```

### Mini Exercise: Loops

**Challenge 1:** Write a loop that prints numbers 1-20, but prints "Fizz" for multiples of 3, "Buzz" for multiples of 5, and "FizzBuzz" for multiples of both.

<details>
<summary>Solution</summary>

```javascript
for (let i = 1; i <= 20; i++) {
  if (i % 3 === 0 && i % 5 === 0) {
    console.log("FizzBuzz");
  } else if (i % 3 === 0) {
    console.log("Fizz");
  } else if (i % 5 === 0) {
    console.log("Buzz");
  } else {
    console.log(i);
  }
}
```
</details>

**Challenge 2:** Create a function that counts how many times a specific value appears in an array.

<details>
<summary>Solution</summary>

```javascript
function countOccurrences(arr, value) {
  let count = 0;
  for (let item of arr) {
    if (item === value) {
      count++;
    }
  }
  return count;
}

const fruits = ["apple", "banana", "apple", "orange", "apple"];
console.log(countOccurrences(fruits, "apple")); // 3
```
</details>

---

## Section 10: Working with Strings

### Creating Strings

```javascript
// Three ways to create strings
const single = 'Hello';           // Single quotes
const double = "World";           // Double quotes
const template = `Hello World`;   // Template literals (backticks)

// All three work the same for simple strings
console.log(single);   // "Hello"
console.log(double);   // "World"
console.log(template); // "Hello World"

// Quotes inside strings
const quote1 = "He said 'Hello'";  // Single quotes inside double
const quote2 = 'She said "Hi"';    // Double quotes inside single
const quote3 = `It's "fine" to mix`; // Both inside template
```

### Template Literals (The Best Way)

**Embed variables and expressions**

```javascript
const name = "Alice";
const age = 25;

// Old way (concatenation)
const oldWay = "Hello, " + name + "! You are " + age + " years old.";

// ✅ New way (template literals)
const newWay = `Hello, ${name}! You are ${age} years old.`;

console.log(newWay); // "Hello, Alice! You are 25 years old."

// Expressions inside ${}
const a = 5;
const b = 10;
console.log(`${a} + ${b} = ${a + b}`); // "5 + 10 = 15"

// Function calls inside ${}
const getName = () => "Bob";
console.log(`User: ${getName()}`); // "User: Bob"
```

**Multi-line strings**

```javascript
// Old way (ugly)
const oldMultiline = "Line 1\n" +
                     "Line 2\n" +
                     "Line 3";

// ✅ New way (clean)
const newMultiline = `
  Line 1
  Line 2
  Line 3
`;

console.log(newMultiline);
// Line 1
// Line 2
// Line 3
```

### String Properties and Methods

**Length property**

```javascript
const text = "Hello";
console.log(text.length); // 5

// Empty string
console.log("".length); // 0

// Useful for validation
const password = "abc";
if (password.length < 8) {
  console.log("Password too short!");
}
```

**Accessing characters**

```javascript
const word = "Hello";

// Bracket notation
console.log(word[0]); // "H" (first character)
console.log(word[4]); // "o" (last character)
console.log(word[5]); // undefined (doesn't exist)

// charAt method
console.log(word.charAt(0)); // "H"
console.log(word.charAt(4)); // "o"
console.log(word.charAt(5)); // "" (empty string, not undefined)

// Last character
console.log(word[word.length - 1]); // "o"
```

### Case Conversion

```javascript
const text = "Hello World";

// Convert to uppercase
console.log(text.toUpperCase()); // "HELLO WORLD"

// Convert to lowercase
console.log(text.toLowerCase()); // "hello world"

// Original string unchanged (strings are immutable)
console.log(text); // "Hello World"

// Store the result
const upper = text.toUpperCase();
console.log(upper); // "HELLO WORLD"
```

**Real use case: Case-insensitive comparison**

```javascript
const input = "Alice";
const stored = "alice";

// ❌ WRONG: Case sensitive
console.log(input === stored); // false

// ✅ CORRECT: Compare lowercase versions
console.log(input.toLowerCase() === stored.toLowerCase()); // true
```

### Searching in Strings

**includes() - Check if substring exists**

```javascript
const email = "alice@example.com";

console.log(email.includes("@"));       // true
console.log(email.includes("example")); // true
console.log(email.includes("gmail"));   // false

// Case sensitive
console.log(email.includes("ALICE"));   // false
console.log(email.toLowerCase().includes("alice")); // true
```

**indexOf() - Find position of substring**

```javascript
const text = "Hello World";

console.log(text.indexOf("World")); // 6 (starts at index 6)
console.log(text.indexOf("o"));     // 4 (first occurrence)
console.log(text.indexOf("xyz"));   // -1 (not found)

// Check if string starts with something
if (text.indexOf("Hello") === 0) {
  console.log("Starts with Hello");
}
```

**startsWith() and endsWith()**

```javascript
const filename = "document.pdf";

console.log(filename.startsWith("doc"));  // true
console.log(filename.endsWith(".pdf"));   // true
console.log(filename.endsWith(".docx"));  // false

// Real use case: File validation
const allowedExtensions = [".jpg", ".png", ".gif"];
const uploadedFile = "photo.jpg";

const isValid = allowedExtensions.some(ext =>
  uploadedFile.endsWith(ext)
);
console.log(isValid); // true
```

### Extracting Parts of Strings

**slice() - Extract substring**

```javascript
const text = "Hello World";

// slice(start, end) - end not included
console.log(text.slice(0, 5));   // "Hello"
console.log(text.slice(6, 11));  // "World"
console.log(text.slice(6));      // "World" (from index 6 to end)

// Negative indices count from end
console.log(text.slice(-5));     // "World" (last 5 characters)
console.log(text.slice(-5, -1)); // "Worl" (exclude last char)
```

**substring() - Similar to slice**

```javascript
const text = "Hello World";

console.log(text.substring(0, 5)); // "Hello"
console.log(text.substring(6));    // "World"

// Difference: substring doesn't accept negative indices
console.log(text.slice(-5));       // "World"
console.log(text.substring(-5));   // "Hello World" (treats -5 as 0)
```

**split() - Break string into array**

```javascript
const csv = "apple,banana,orange";
const fruits = csv.split(",");
console.log(fruits); // ["apple", "banana", "orange"]

// Split by spaces
const sentence = "Hello World Everyone";
const words = sentence.split(" ");
console.log(words); // ["Hello", "World", "Everyone"]

// Split into characters
const word = "Hello";
const chars = word.split("");
console.log(chars); // ["H", "e", "l", "l", "o"]

// Real use case: Parse full name
const fullName = "Alice Johnson";
const [firstName, lastName] = fullName.split(" ");
console.log(firstName); // "Alice"
console.log(lastName);  // "Johnson"
```

### Modifying Strings

**trim() - Remove whitespace**

```javascript
const input = "  hello  ";

console.log(input.trim());      // "hello"
console.log(input.trimStart()); // "hello  "
console.log(input.trimEnd());   // "  hello"

// Real use case: Clean user input
const username = "  Alice  ";
const cleaned = username.trim();
console.log(cleaned); // "Alice"
```

**replace() - Replace text**

```javascript
const text = "Hello World";

// Replace first occurrence
console.log(text.replace("World", "Everyone"));
// "Hello Everyone"

// Original unchanged
console.log(text); // "Hello World"

// Replace all occurrences (use replaceAll or regex)
const repeated = "cat cat cat";
console.log(repeated.replace("cat", "dog"));
// "dog cat cat" (only first)

console.log(repeated.replaceAll("cat", "dog"));
// "dog dog dog" (all)

// Case insensitive replace with regex
const text2 = "Hello WORLD hello";
console.log(text2.replace(/hello/i, "Hi"));
// "Hi WORLD hello" (replaces first, case insensitive)

console.log(text2.replace(/hello/gi, "Hi"));
// "Hi WORLD Hi" (replaces all, case insensitive)
```

**repeat() - Repeat string**

```javascript
console.log("ha".repeat(3));  // "hahaha"
console.log("*".repeat(5));   // "*****"

// Real use case: Create divider
const divider = "-".repeat(50);
console.log(divider); // "--------------------------------------------------"
```

**padStart() and padEnd() - Add padding**

```javascript
const num = "5";

console.log(num.padStart(3, "0")); // "005"
console.log(num.padEnd(3, "0"));   // "500"

// Real use case: Format time
const hours = 9;
const minutes = 5;
const time = `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
console.log(time); // "09:05"
```

### Combining Strings

**concat() - Join strings**

```javascript
const first = "Hello";
const second = "World";

console.log(first.concat(" ", second)); // "Hello World"

// But template literals are better:
console.log(`${first} ${second}`); // "Hello World"
```

**Array join() - Combine array into string**

```javascript
const words = ["Hello", "World", "Everyone"];

console.log(words.join(" "));  // "Hello World Everyone"
console.log(words.join("-"));  // "Hello-World-Everyone"
console.log(words.join(""));   // "HelloWorldEveryone"

// Real use case: Create CSV
const row = ["Alice", "25", "SF"];
const csv = row.join(",");
console.log(csv); // "Alice,25,SF"
```

### String Immutability

**Strings cannot be changed - you create new strings**

```javascript
let text = "Hello";

// ❌ This doesn't work
text[0] = "h";
console.log(text); // Still "Hello" (unchanged)

// ✅ Create new string instead
text = "h" + text.slice(1);
console.log(text); // "hello"

// Or
text = text.toLowerCase();
console.log(text); // "hello"
```

### Practical Examples

**Example 1: Validate email format**

```javascript
function isValidEmail(email) {
  // Basic validation
  return (
    email.includes("@") &&
    email.includes(".") &&
    email.indexOf("@") > 0 &&
    email.indexOf(".") > email.indexOf("@")
  );
}

console.log(isValidEmail("user@example.com")); // true
console.log(isValidEmail("invalid.email"));    // false
console.log(isValidEmail("@example.com"));     // false
```

**Example 2: Format phone number**

```javascript
function formatPhone(phone) {
  // Remove all non-digits
  const cleaned = phone.replace(/\D/g, "");

  // Format as (123) 456-7890
  if (cleaned.length === 10) {
    return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
  }

  return "Invalid phone number";
}

console.log(formatPhone("1234567890"));    // "(123) 456-7890"
console.log(formatPhone("123-456-7890"));  // "(123) 456-7890"
console.log(formatPhone("(123) 456-7890")); // "(123) 456-7890"
```

**Example 3: Title case converter**

```javascript
function toTitleCase(text) {
  return text
    .toLowerCase()
    .split(" ")
    .map(word => word[0].toUpperCase() + word.slice(1))
    .join(" ");
}

console.log(toTitleCase("hello world"));           // "Hello World"
console.log(toTitleCase("the great gatsby"));      // "The Great Gatsby"
console.log(toTitleCase("JAVASCRIPT IS AWESOME")); // "Javascript Is Awesome"
```

**Example 4: Extract domain from email**

```javascript
function getDomain(email) {
  const atIndex = email.indexOf("@");
  if (atIndex === -1) return null;
  return email.slice(atIndex + 1);
}

console.log(getDomain("user@example.com"));  // "example.com"
console.log(getDomain("alice@gmail.com"));   // "gmail.com"
console.log(getDomain("invalid"));           // null
```

**Example 5: Truncate long text**

```javascript
function truncate(text, maxLength) {
  if (text.length <= maxLength) {
    return text;
  }
  return text.slice(0, maxLength - 3) + "...";
}

console.log(truncate("This is a very long sentence", 10));
// "This is..."

console.log(truncate("Short", 10));
// "Short"
```

### Mini Exercise: Strings

**Challenge 1:** Write a function that takes a name and returns initials (e.g., "Alice Johnson" → "AJ").

<details>
<summary>Solution</summary>

```javascript
function getInitials(name) {
  return name
    .split(" ")
    .map(word => word[0].toUpperCase())
    .join("");
}

console.log(getInitials("Alice Johnson"));      // "AJ"
console.log(getInitials("John Paul Smith"));    // "JPS"
```
</details>

**Challenge 2:** Write a function that counts how many vowels are in a string.

<details>
<summary>Solution</summary>

```javascript
function countVowels(text) {
  const vowels = "aeiouAEIOU";
  let count = 0;

  for (let char of text) {
    if (vowels.includes(char)) {
      count++;
    }
  }

  return count;
}

console.log(countVowels("Hello World")); // 3
console.log(countVowels("JavaScript"));  // 3
```
</details>

---

## Section 11: Null, Undefined, and Error Handling

### Null vs Undefined

**undefined - Variable declared but not assigned**

```javascript
let name;
console.log(name); // undefined

// Function with no return
function doNothing() {
  // No return statement
}
console.log(doNothing()); // undefined

// Object property that doesn't exist
const user = { name: "Alice" };
console.log(user.age); // undefined

// Array element that doesn't exist
const arr = [1, 2, 3];
console.log(arr[10]); // undefined
```

**null - Intentional absence of value**

```javascript
// You assign null deliberately
let data = null; // "I know there's no data"

// API might return null
const user = findUser(999); // null if not found

// Clear a value
let currentUser = { name: "Alice" };
currentUser = null; // User logged out
```

**The difference:**

```javascript
let notDefined;        // undefined (not set)
let deliberately = null; // null (deliberately empty)

console.log(typeof notDefined);  // "undefined"
console.log(typeof deliberately); // "object" ⚠️ JavaScript quirk!

// Checking for null vs undefined
console.log(notDefined === undefined); // true
console.log(deliberately === null);    // true

console.log(notDefined == deliberately); // true ⚠️ Loose equality
console.log(notDefined === deliberately); // false ✓ Strict equality
```

### Checking for Null/Undefined

```javascript
const value = null;

// Check for both null and undefined
if (value == null) {
  console.log("Value is null or undefined");
}

// Check specifically for null
if (value === null) {
  console.log("Value is exactly null");
}

// Check specifically for undefined
if (value === undefined) {
  console.log("Value is exactly undefined");
}

// Check if value exists (not null or undefined)
if (value != null) {
  console.log("Value exists");
}

// Truthy/falsy check (also catches 0, "", false)
if (value) {
  console.log("Value is truthy");
} else {
  console.log("Value is falsy");
}
```

### Nullish Coalescing Operator (??)

**Provide default value for null or undefined**

```javascript
const name = null;

// Old way (has bugs with falsy values)
const displayName1 = name || "Guest";
console.log(displayName1); // "Guest"

// ✅ New way (only checks null/undefined)
const displayName2 = name ?? "Guest";
console.log(displayName2); // "Guest"

// The difference:
const count = 0;
console.log(count || 10);  // 10 ⚠️ Treats 0 as falsy
console.log(count ?? 10);  // 0 ✓ Only null/undefined trigger default

const text = "";
console.log(text || "default");  // "default" ⚠️ Treats "" as falsy
console.log(text ?? "default");  // "" ✓ Only null/undefined trigger default
```

**Real use case:**

```javascript
function greetUser(name) {
  const displayName = name ?? "Guest";
  return `Hello, ${displayName}!`;
}

console.log(greetUser("Alice"));    // "Hello, Alice!"
console.log(greetUser(null));       // "Hello, Guest!"
console.log(greetUser(undefined));  // "Hello, Guest!"
console.log(greetUser(""));         // "Hello, !" (empty string is not null)
```

### Optional Chaining (?.)

**Safely access nested properties**

```javascript
const user = {
  name: "Alice",
  address: {
    city: "SF"
  }
};

// Without optional chaining
// console.log(user.profile.bio); // ❌ Error: Cannot read property 'bio' of undefined

// Old way (manual checking)
const bio1 = user.profile && user.profile.bio;
console.log(bio1); // undefined

// ✅ New way (optional chaining)
const bio2 = user.profile?.bio;
console.log(bio2); // undefined (no error!)

// Nested optional chaining
const street = user.address?.street?.number;
console.log(street); // undefined

// With arrays
const users = [
  { name: "Alice", settings: { theme: "dark" } },
  { name: "Bob" }
];

console.log(users[0]?.settings?.theme); // "dark"
console.log(users[1]?.settings?.theme); // undefined (no error!)

// With function calls
const data = null;
const result = data?.doSomething?.(); // undefined (no error!)
```

**Combine with nullish coalescing:**

```javascript
const user = {
  name: "Alice"
};

const theme = user.settings?.theme ?? "light";
console.log(theme); // "light" (default)
```

### Error Types

```javascript
// 1. ReferenceError - variable doesn't exist
// console.log(doesNotExist); // ReferenceError

// 2. TypeError - wrong type or method doesn't exist
// null.toString(); // TypeError: Cannot read property 'toString' of null

// 3. SyntaxError - invalid code
// const x = ; // SyntaxError: Unexpected token

// 4. RangeError - value out of range
// const arr = new Array(-1); // RangeError: Invalid array length

// 5. Custom error
// throw new Error("Something went wrong!");
```

### try...catch: Handle Errors

**Basic structure:**

```javascript
try {
  // Code that might throw an error
  const result = riskyOperation();
  console.log(result);
} catch (error) {
  // Handle the error
  console.log("An error occurred:", error.message);
} finally {
  // Always runs (optional)
  console.log("Cleanup code here");
}
```

**Real example: Parse JSON**

```javascript
function parseJSON(jsonString) {
  try {
    const data = JSON.parse(jsonString);
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

// Valid JSON
const result1 = parseJSON('{"name": "Alice"}');
console.log(result1);
// { success: true, data: { name: "Alice" } }

// Invalid JSON
const result2 = parseJSON('not valid json');
console.log(result2);
// { success: false, error: "Unexpected token n in JSON at position 0" }
```

**Example: Safe property access**

```javascript
function getUserEmail(user) {
  try {
    return user.contact.email.toLowerCase();
  } catch (error) {
    console.log("Could not get email:", error.message);
    return null;
  }
}

const user1 = {
  contact: {
    email: "ALICE@EXAMPLE.COM"
  }
};

const user2 = { name: "Bob" }; // No contact object

console.log(getUserEmail(user1)); // "alice@example.com"
console.log(getUserEmail(user2)); // null (caught error)
```

### Throwing Errors

**Create and throw your own errors**

```javascript
function divide(a, b) {
  if (b === 0) {
    throw new Error("Cannot divide by zero!");
  }
  return a / b;
}

try {
  console.log(divide(10, 2)); // 5
  console.log(divide(10, 0)); // Throws error
} catch (error) {
  console.log("Error:", error.message); // "Error: Cannot divide by zero!"
}
```

**Custom error with validation:**

```javascript
function createUser(name, age) {
  if (!name) {
    throw new Error("Name is required");
  }

  if (typeof age !== "number" || age < 0) {
    throw new Error("Age must be a positive number");
  }

  if (age < 18) {
    throw new Error("Must be 18 or older");
  }

  return { name, age, createdAt: new Date() };
}

try {
  const user1 = createUser("Alice", 25);
  console.log(user1); // Success

  const user2 = createUser("", 30);
  console.log(user2); // Never runs
} catch (error) {
  console.log("Validation error:", error.message);
  // "Validation error: Name is required"
}
```

### Defensive Programming Patterns

**Guard clauses:**

```javascript
function processUser(user) {
  // Check for problems first, exit early
  if (!user) {
    console.log("No user provided");
    return;
  }

  if (!user.email) {
    console.log("User has no email");
    return;
  }

  // Main logic only runs if all checks pass
  console.log("Processing:", user.email);
  // ... rest of code
}

processUser(null);                    // "No user provided"
processUser({ name: "Alice" });       // "User has no email"
processUser({ email: "a@b.com" });    // "Processing: a@b.com"
```

**Default values:**

```javascript
function greet(name = "Guest", greeting = "Hello") {
  return `${greeting}, ${name}!`;
}

console.log(greet("Alice", "Hi"));  // "Hi, Alice!"
console.log(greet("Bob"));          // "Hello, Bob!"
console.log(greet());               // "Hello, Guest!"
```

**Type checking:**

```javascript
function double(num) {
  if (typeof num !== "number") {
    throw new Error("Argument must be a number");
  }
  return num * 2;
}

console.log(double(5));     // 10
// console.log(double("5")); // Error: Argument must be a number
```

### Practical Error Handling

**Example: API call simulation**

```javascript
async function fetchUser(id) {
  try {
    // Simulated API call
    if (id < 0) {
      throw new Error("Invalid ID");
    }

    if (id > 100) {
      return null; // User not found
    }

    return { id, name: `User${id}`, email: `user${id}@example.com` };
  } catch (error) {
    console.error("Failed to fetch user:", error.message);
    return null;
  }
}

// Usage
const user1 = await fetchUser(5);   // { id: 5, name: "User5", ... }
const user2 = await fetchUser(-1);  // null (caught error)
const user3 = await fetchUser(999); // null (not found)
```

**Example: Form validation**

```javascript
function validateForm(data) {
  const errors = [];

  if (!data.email?.includes("@")) {
    errors.push("Invalid email format");
  }

  if (!data.password || data.password.length < 8) {
    errors.push("Password must be at least 8 characters");
  }

  if (data.age != null && (data.age < 18 || data.age > 120)) {
    errors.push("Age must be between 18 and 120");
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

const result1 = validateForm({
  email: "alice@example.com",
  password: "secret123",
  age: 25
});
console.log(result1); // { isValid: true, errors: [] }

const result2 = validateForm({
  email: "invalid",
  password: "123",
  age: 15
});
console.log(result2);
// { isValid: false, errors: ["Invalid email format", "Password must be at least 8 characters", "Age must be between 18 and 120"] }
```

### Mini Exercise: Error Handling

**Challenge:** Write a function that safely gets a nested property from an object, returning a default value if the property doesn't exist.

```javascript
// Should work like this:
const user = {
  profile: {
    settings: {
      theme: "dark"
    }
  }
};

getNestedValue(user, "profile.settings.theme", "light"); // "dark"
getNestedValue(user, "profile.bio.text", "No bio");      // "No bio"
```

<details>
<summary>Solution</summary>

```javascript
function getNestedValue(obj, path, defaultValue) {
  try {
    const keys = path.split(".");
    let current = obj;

    for (let key of keys) {
      if (current == null) {
        return defaultValue;
      }
      current = current[key];
    }

    return current ?? defaultValue;
  } catch (error) {
    return defaultValue;
  }
}

// Or with optional chaining (modern):
function getNestedValue(obj, path, defaultValue) {
  const keys = path.split(".");
  let current = obj;

  for (let key of keys) {
    current = current?.[key];
  }

  return current ?? defaultValue;
}
```
</details>

---

## Section 12: Scope, Hoisting, and Closures

### Scope: Where Variables Live

**Three types of scope:**

```javascript
// 1. Global scope - accessible everywhere
const globalVar = "I'm global";

function test1() {
  console.log(globalVar); // ✅ Works
}

function test2() {
  console.log(globalVar); // ✅ Works
}

// 2. Function scope - accessible only in function
function myFunction() {
  const functionVar = "I'm local to this function";
  console.log(functionVar); // ✅ Works
}

// console.log(functionVar); // ❌ Error: functionVar is not defined

// 3. Block scope - accessible only in block (let/const)
if (true) {
  const blockVar = "I'm in a block";
  let alsoBlock = "Me too";
  var leaksOut = "I leak out!"; // var ignores block scope

  console.log(blockVar);  // ✅ Works
  console.log(alsoBlock); // ✅ Works
}

// console.log(blockVar);  // ❌ Error
// console.log(alsoBlock); // ❌ Error
console.log(leaksOut);     // ✅ Works (var leaks!)
```

**Visual scope chain:**

```javascript
const global = "global";

function outer() {
  const outerVar = "outer";

  function inner() {
    const innerVar = "inner";

    // inner can access:
    console.log(innerVar);  // ✅ Own scope
    console.log(outerVar);  // ✅ Parent scope
    console.log(global);    // ✅ Global scope
  }

  inner();
  // console.log(innerVar); // ❌ Can't access child scope
}

outer();
```

**Scope lookup:**

```
When code runs, JavaScript looks for variables in this order:
1. Current scope
2. Parent scope
3. Parent's parent scope
4. ... all the way up to global scope
5. If not found anywhere → ReferenceError
```

### Hoisting: The Weird Behavior

**var is hoisted (moved to top)**

```javascript
// What you write:
console.log(name); // undefined (not an error!)
var name = "Alice";
console.log(name); // "Alice"

// What JavaScript actually does:
var name;          // Declaration hoisted
console.log(name); // undefined
name = "Alice";    // Assignment stays in place
console.log(name); // "Alice"
```

**let and const are NOT hoisted (safely)**

```javascript
// console.log(age); // ❌ ReferenceError: Cannot access before initialization
let age = 25;
console.log(age); // 25

// const works the same
// console.log(PI); // ❌ ReferenceError
const PI = 3.14;
console.log(PI); // 3.14
```

**Function declarations are hoisted**

```javascript
// You can call before definition
greet(); // "Hello!" - Works!

function greet() {
  console.log("Hello!");
}

// But function expressions are NOT
// sayHi(); // ❌ Error: Cannot access before initialization
const sayHi = function() {
  console.log("Hi!");
};
```

**Why this matters:**

```javascript
// ❌ BAD: Leads to bugs
var count = 5;

function increment() {
  console.log(count); // undefined (not 5!)
  var count = 10;     // Hoisted, shadows outer count
  count++;
  console.log(count); // 11
}

increment();
console.log(count); // 5 (outer unchanged)

// ✅ GOOD: Use let/const, get error if accessing too early
let count = 5;

function increment() {
  // console.log(count); // ❌ Error: Cannot access before initialization
  let count = 10;
  count++;
  console.log(count); // 11
}
```

### Closures: Functions That Remember

**A closure is a function that remembers variables from where it was created**

```javascript
function outer() {
  const message = "Hello";

  function inner() {
    console.log(message); // inner "closes over" message
  }

  return inner;
}

const myFunc = outer(); // outer() returns inner function
myFunc(); // "Hello" - still remembers message!

// Even though outer() finished executing,
// inner() still has access to message
```

**Visual explanation:**

```
1. outer() creates variable message
2. outer() defines inner() - inner can see message
3. outer() returns inner function
4. outer() finishes executing
5. BUT inner() still remembers message (closure!)
6. When we call myFunc(), it can still access message
```

**Practical example: Counter**

```javascript
function createCounter() {
  let count = 0; // Private variable

  return {
    increment() {
      count++;
      return count;
    },
    decrement() {
      count--;
      return count;
    },
    getCount() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.increment()); // 3
console.log(counter.decrement()); // 2
console.log(counter.getCount());  // 2

// Can't access count directly
// console.log(counter.count); // undefined
// count is private! Only accessible through methods
```

**Example: Create multiple independent counters**

```javascript
function createCounter(start = 0) {
  let count = start;

  return {
    increment: () => ++count,
    decrement: () => --count,
    reset: () => count = start,
    getCount: () => count
  };
}

const counter1 = createCounter(0);
const counter2 = createCounter(100);

counter1.increment(); // 1
counter1.increment(); // 2

counter2.increment(); // 101
counter2.increment(); // 102

console.log(counter1.getCount()); // 2
console.log(counter2.getCount()); // 102

// Each counter has its own private count!
```

**Example: Event handler with closure**

```javascript
function createButton(label) {
  let clickCount = 0;

  return {
    label,
    onClick() {
      clickCount++;
      console.log(`${label} clicked ${clickCount} times`);
    }
  };
}

const loginBtn = createButton("Login");
const signupBtn = createButton("Signup");

loginBtn.onClick();  // "Login clicked 1 times"
loginBtn.onClick();  // "Login clicked 2 times"
signupBtn.onClick(); // "Signup clicked 1 times"

// Each button remembers its own clickCount
```

**Example: Private data**

```javascript
function createUser(name, email) {
  // Private variables
  let password = null;
  let failedAttempts = 0;

  return {
    // Public methods
    getName: () => name,
    getEmail: () => email,

    setPassword(pwd) {
      if (pwd.length >= 8) {
        password = pwd;
        return true;
      }
      return false;
    },

    login(pwd) {
      if (pwd === password) {
        failedAttempts = 0;
        return { success: true };
      }

      failedAttempts++;
      return {
        success: false,
        attempts: failedAttempts
      };
    }
  };
}

const user = createUser("Alice", "alice@example.com");
user.setPassword("secret123");

console.log(user.getName());  // "Alice"
console.log(user.getEmail()); // "alice@example.com"

// Can't access password directly
console.log(user.password); // undefined (private!)

console.log(user.login("wrong"));    // { success: false, attempts: 1 }
console.log(user.login("secret123")); // { success: true }
```

### Common Closure Pitfall: Loop + var

```javascript
// ❌ WRONG: All buttons log 3
const buttons = [];

for (var i = 0; i < 3; i++) {
  buttons.push(function() {
    console.log("Button " + i);
  });
}

buttons[0](); // "Button 3" (expected 0!)
buttons[1](); // "Button 3" (expected 1!)
buttons[2](); // "Button 3" (expected 2!)

// Why? All functions share same 'i', which is 3 after loop

// ✅ FIX 1: Use let (block scoped)
const buttons2 = [];

for (let i = 0; i < 3; i++) {
  buttons2.push(function() {
    console.log("Button " + i);
  });
}

buttons2[0](); // "Button 0" ✓
buttons2[1](); // "Button 1" ✓
buttons2[2](); // "Button 2" ✓

// ✅ FIX 2: Create closure with IIFE (old way)
const buttons3 = [];

for (var i = 0; i < 3; i++) {
  buttons3.push((function(index) {
    return function() {
      console.log("Button " + index);
    };
  })(i));
}

buttons3[0](); // "Button 0" ✓
```

### Scope and Closures in React

```javascript
// React component closures
function Counter() {
  const [count, setCount] = useState(0);

  // This function closes over 'count'
  const handleClick = () => {
    setCount(count + 1);
  };

  return <button onClick={handleClick}>Count: {count}</button>;
}

// Custom hooks use closures
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : initialValue;
  });

  // Closure remembers 'key'
  const updateValue = (newValue) => {
    setValue(newValue);
    localStorage.setItem(key, JSON.stringify(newValue));
  };

  return [value, updateValue];
}

// Event handlers in loops
function TodoList({ todos }) {
  // Each handler closes over specific todo.id
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
          <button onClick={() => deleteTodo(todo.id)}>
            Delete
          </button>
        </li>
      ))}
    </ul>
  );
}
```

### Mini Exercise: Closures

**Challenge:** Create a function `createMultiplier` that returns a function which multiplies by a specific number.

```javascript
// Should work like:
const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

<details>
<summary>Solution</summary>

```javascript
function createMultiplier(multiplier) {
  return function(num) {
    return num * multiplier;
  };
}

// Or with arrow functions:
const createMultiplier = (multiplier) => (num) => num * multiplier;

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```
</details>

---

## Section 8: Objects Explained Visually

### The Filing Cabinet Analogy

An object is like a filing cabinet where each drawer has a label (key) and contains something (value).

```javascript
// Object = labeled drawers with contents
const user = {
  name: "Alice",      // Drawer labeled "name" contains "Alice"
  age: 25,           // Drawer labeled "age" contains 25
  email: "alice@example.com"
};
```

### Creating Objects

```javascript
// Object literal (most common)
const person = {
  name: "Bob",
  age: 30,
  isStudent: false
};

// Empty object
const empty = {};

// Adding properties
empty.name = "Carol";
empty.age = 28;
console.log(empty); // { name: "Carol", age: 28 }
```

### Accessing Properties: Dot vs Bracket Notation

```javascript
const user = {
  name: "Alice",
  age: 25,
  "favorite color": "blue" // Property with space (needs quotes)
};

// Dot notation (most common, cleaner)
console.log(user.name); // "Alice"
console.log(user.age);  // 25

// Bracket notation (when property name has spaces or is dynamic)
console.log(user["favorite color"]); // "blue"

// Dynamic property access
const property = "name";
console.log(user[property]); // "Alice"

// When to use each:
// Dot notation: user.name ✅ Clean and readable
// Bracket notation: user["name"] ✅ When property is dynamic or has spaces
```

### Adding, Updating, Deleting Properties

```javascript
const user = {
  name: "Alice",
  age: 25
};

// Add new property
user.email = "alice@example.com";
console.log(user); 
// { name: "Alice", age: 25, email: "alice@example.com" }

// Update existing property
user.age = 26;
console.log(user.age); // 26

// Delete property
delete user.email;
console.log(user); 
// { name: "Alice", age: 26 }
```

### Nested Objects

```javascript
const user = {
  name: "Alice",
  age: 25,
  address: {
    street: "123 Main St",
    city: "Boston",
    zip: "02101",
    coordinates: {
      lat: 42.3601,
      lng: -71.0589
    }
  }
};

// Accessing nested properties
console.log(user.address.city);              // "Boston"
console.log(user.address.coordinates.lat);   // 42.3601

// Be careful with undefined
// console.log(user.phone.number); // ❌ Error: Cannot read property 'number' of undefined

// Safe access (check first)
if (user.phone) {
  console.log(user.phone.number);
}

// Or use optional chaining (modern JS)
console.log(user.phone?.number); // undefined (no error!)
```

### Object Methods

```javascript
const calculator = {
  add: function(a, b) {
    return a + b;
  },
  subtract: function(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3));      // 8
console.log(calculator.subtract(10, 4)); // 6

// Shorthand method syntax (modern)
const calculator = {
  add(a, b) {
    return a + b;
  },
  subtract(a, b) {
    return a - b;
  }
};
```

### The `this` Keyword

```javascript
const user = {
  name: "Alice",
  age: 25,
  greet() {
    // 'this' refers to the object itself
    return "Hi, I'm " + this.name;
  },
  celebrateBirthday() {
    this.age++; // Increment age property
    return "Happy birthday! You're now " + this.age;
  }
};

console.log(user.greet());             // "Hi, I'm Alice"
console.log(user.celebrateBirthday()); // "Happy birthday! You're now 26"
console.log(user.age);                 // 26
```

### Object Destructuring (Critical for React)

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com"
};

// Old way - access each property
const name = user.name;
const age = user.age;
const email = user.email;

// New way - destructuring (much cleaner!)
const { name, age, email } = user;
console.log(name);  // "Alice"
console.log(age);   // 25
console.log(email); // "alice@example.com"

// Rename while destructuring
const { name: userName, age: userAge } = user;
console.log(userName); // "Alice"
console.log(userAge);  // 25

// Default values
const { name, age, phone = "N/A" } = user;
console.log(phone); // "N/A" (doesn't exist in user)

// Nested destructuring
const user = {
  name: "Alice",
  address: {
    city: "Boston",
    zip: "02101"
  }
};

const { address: { city, zip } } = user;
console.log(city); // "Boston"
console.log(zip);  // "02101"
```

### Why This Matters in React

```javascript
// React props are objects - destructuring makes code cleaner

// ❌ Without destructuring
function UserCard(props) {
  return (
    <div>
      <h2>{props.name}</h2>
      <p>Age: {props.age}</p>
      <p>Email: {props.email}</p>
    </div>
  );
}

// ✅ With destructuring (React standard)
function UserCard({ name, age, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>Age: {age}</p>
      <p>Email: {email}</p>
    </div>
  );
}
```

### Checking if Property Exists

```javascript
const user = {
  name: "Alice",
  age: 25
};

// Method 1: in operator
console.log("name" in user);  // true
console.log("email" in user); // false

// Method 2: hasOwnProperty
console.log(user.hasOwnProperty("name"));  // true
console.log(user.hasOwnProperty("email")); // false

// Method 3: Check if undefined
console.log(user.name !== undefined);  // true
console.log(user.email !== undefined); // false
```

### Object.keys, values, entries

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com"
};

// Get all keys
console.log(Object.keys(user)); 
// ["name", "age", "email"]

// Get all values
console.log(Object.values(user)); 
// ["Alice", 25, "alice@example.com"]

// Get all entries (key-value pairs)
console.log(Object.entries(user));
// [["name", "Alice"], ["age", 25], ["email", "alice@example.com"]]

// Loop through object
Object.keys(user).forEach(key => {
  console.log(key, "=", user[key]);
});
// name = Alice
// age = 25
// email = alice@example.com
```

### Copying Objects

```javascript
const original = { name: "Alice", age: 25 };

// ❌ WRONG: Assignment creates reference, not copy
const copy = original;
copy.age = 30;
console.log(original.age); // 30 - Oops! Modified original

// ✅ CORRECT: Spread operator creates shallow copy
const copy = { ...original };
copy.age = 30;
console.log(original.age); // 25 - Original unchanged
console.log(copy.age);     // 30

// ✅ CORRECT: Object.assign
const copy = Object.assign({}, original);

// Add properties while copying
const extended = { ...original, email: "alice@example.com" };
console.log(extended);
// { name: "Alice", age: 25, email: "alice@example.com" }
```

### Mini Exercise: Objects

**Challenge:** Create a product object with name, price, and a method that applies a discount percentage.

<details>
<summary>Solution</summary>

```javascript
const product = {
  name: "Laptop",
  price: 1000,
  applyDiscount(percentage) {
    this.price = this.price * (1 - percentage / 100);
    return this.price;
  }
};

console.log(product.applyDiscount(10)); // 900
console.log(product.price);             // 900
```
</details>

---

## Section 9: Loops & Iteration

### while Loop

```javascript
// Runs WHILE condition is true
let count = 0;

while (count < 5) {
  console.log("Count:", count);
  count++; // MUST increment or infinite loop!
}
// Output: Count: 0, Count: 1, Count: 2, Count: 3, Count: 4
```

**Real example: Waiting for user input**

```javascript
let password = "";

while (password !== "secret") {
  password = prompt("Enter password:"); // In browser
}
console.log("Access granted!");
```

### do...while Loop

```javascript
// Runs AT LEAST ONCE, then checks condition
let count = 0;

do {
  console.log("Count:", count);
  count++;
} while (count < 5);

// Difference: Runs once even if condition is false
let num = 10;

do {
  console.log("This runs once"); // Prints!
} while (num < 5); // Condition is false
```

### for Loop

```javascript
// for (initialization; condition; increment)
for (let i = 0; i < 5; i++) {
  console.log("i =", i);
}
// Output: i = 0, i = 1, i = 2, i = 3, i = 4

// How it works:
// 1. let i = 0         → Run once at start
// 2. i < 5             → Check before each iteration
// 3. console.log(...)  → Run the code block
// 4. i++               → Run after each iteration
// 5. Go back to step 2

// Loop through array
const fruits = ["apple", "banana", "orange"];

for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}
```

### for...of (Modern, for Arrays)

```javascript
const fruits = ["apple", "banana", "orange"];

// Get each value directly
for (let fruit of fruits) {
  console.log(fruit);
}
// Output: apple, banana, orange

// Get index too (if needed)
for (let [index, fruit] of fruits.entries()) {
  console.log(index, fruit);
}
// Output: 0 apple, 1 banana, 2 orange
```

### for...in (for Objects)

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com"
};

// Loop through object keys
for (let key in user) {
  console.log(key, "=", user[key]);
}
// Output:
// name = Alice
// age = 25
// email = alice@example.com
```

**⚠️ Warning: Don't use for...in with arrays**

```javascript
const arr = ["a", "b", "c"];

// ❌ for...in gives keys (not ideal for arrays)
for (let key in arr) {
  console.log(key); // "0", "1", "2" (strings!)
}

// ✅ for...of gives values (better for arrays)
for (let value of arr) {
  console.log(value); // "a", "b", "c"
}
```

### break and continue

```javascript
// break - exit loop completely
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break; // Stop loop when i is 5
  }
  console.log(i);
}
// Output: 0, 1, 2, 3, 4

// continue - skip to next iteration
for (let i = 0; i < 5; i++) {
  if (i === 2) {
    continue; // Skip when i is 2
  }
  console.log(i);
}
// Output: 0, 1, 3, 4 (skipped 2)
```

**Real example: Find first match**

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Carol" }
];

let found = null;

for (let user of users) {
  if (user.id === 2) {
    found = user;
    break; // Stop searching once found
  }
}

console.log(found); // { id: 2, name: "Bob" }
```

### Combining Loops + Arrays + Conditionals

**Example 1: Filter even numbers**

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = [];

for (let num of numbers) {
  if (num % 2 === 0) {
    evens.push(num);
  }
}

console.log(evens); // [2, 4, 6, 8, 10]
```

**Example 2: Build HTML**

```javascript
const items = ["Apple", "Banana", "Orange"];
let html = "<ul>";

for (let item of items) {
  html += "<li>" + item + "</li>";
}

html += "</ul>";

console.log(html);
// <ul><li>Apple</li><li>Banana</li><li>Orange</li></ul>
```

**Example 3: Multiplication table**

```javascript
for (let i = 1; i <= 5; i++) {
  for (let j = 1; j <= 5; j++) {
    console.log(`${i} x ${j} = ${i * j}`);
  }
}
```

### When to Use Which Loop

```javascript
// for → when you need index or specific number of iterations
for (let i = 0; i < 10; i++) { }

// for...of → when you need array values
for (let item of array) { }

// for...in → when you need object keys
for (let key in object) { }

// while → when you don't know how many iterations
while (condition) { }

// Array methods (map, filter, etc.) → when transforming data
array.map(item => item * 2)
```

---

## Section 10: Working with Strings

### String Basics

```javascript
const name = "Alice";
const greeting = 'Hello';
const message = `Welcome, ${name}!`; // Template literal

// Length
console.log(name.length); // 5

// Access characters (strings are like arrays)
console.log(name[0]);  // "A"
console.log(name[4]);  // "e"
console.log(name[10]); // undefined
```

### String Methods

**Case conversion:**

```javascript
const text = "Hello World";

console.log(text.toUpperCase()); // "HELLO WORLD"
console.log(text.toLowerCase()); // "hello world"

// Original unchanged (strings are immutable)
console.log(text); // "Hello World"
```

**Searching:**

```javascript
const text = "Hello World";

console.log(text.includes("World")); // true
console.log(text.includes("world")); // false (case-sensitive)

console.log(text.indexOf("o"));      // 4 (first occurrence)
console.log(text.indexOf("o", 5));   // 7 (start searching from index 5)
console.log(text.indexOf("xyz"));    // -1 (not found)

console.log(text.startsWith("Hello")); // true
console.log(text.endsWith("World"));   // true
```

**Extracting:**

```javascript
const text = "Hello World";

// slice(start, end) - end not included
console.log(text.slice(0, 5));  // "Hello"
console.log(text.slice(6));     // "World" (from 6 to end)
console.log(text.slice(-5));    // "World" (last 5 characters)

// substring(start, end) - similar to slice
console.log(text.substring(0, 5)); // "Hello"

// substr(start, length) - deprecated, avoid
```

**Replacing:**

```javascript
const text = "Hello World";

console.log(text.replace("World", "JavaScript")); // "Hello JavaScript"
console.log(text.replace("o", "0")); // "Hell0 World" (only first occurrence)

// Replace all occurrences
console.log(text.replaceAll("o", "0")); // "Hell0 W0rld"

// Or use regex
console.log(text.replace(/o/g, "0")); // "Hell0 W0rld"
```

**Trimming:**

```javascript
const text = "  Hello World  ";

console.log(text.trim());       // "Hello World" (both ends)
console.log(text.trimStart());  // "Hello World  " (start only)
console.log(text.trimEnd());    // "  Hello World" (end only)
```

### Template Literals vs Concatenation

```javascript
const name = "Alice";
const age = 25;

// ❌ Concatenation (old, messy)
const message1 = "Hello, " + name + "! You are " + age + " years old.";

// ✅ Template literal (modern, clean)
const message2 = `Hello, ${name}! You are ${age} years old.`;

// Multi-line strings
const html = `
  <div>
    <h1>${name}</h1>
    <p>Age: ${age}</p>
  </div>
`;

// Expressions inside ${}
const message3 = `Next year you'll be ${age + 1}`;
const message4 = `Status: ${age >= 18 ? "Adult" : "Minor"}`;
```

### split() and join()

```javascript
// split - string to array
const csv = "apple,banana,orange";
const fruits = csv.split(",");
console.log(fruits); // ["apple", "banana", "orange"]

const sentence = "Hello World";
const words = sentence.split(" ");
console.log(words); // ["Hello", "World"]

// Split every character
const letters = "Hello".split("");
console.log(letters); // ["H", "e", "l", "l", "o"]

// join - array to string
const fruits = ["apple", "banana", "orange"];
const csv = fruits.join(",");
console.log(csv); // "apple,banana,orange"

const words = ["Hello", "World"];
const sentence = words.join(" ");
console.log(sentence); // "Hello World"
```

**Real example: Reversing a string**

```javascript
function reverseString(str) {
  return str.split("").reverse().join("");
}

console.log(reverseString("Hello")); // "olleH"

// Step by step:
// "Hello" 
// → split("") → ["H", "e", "l", "l", "o"]
// → reverse() → ["o", "l", "l", "e", "H"]
// → join("") → "olleH"
```

### Real-World Use Cases

**Format UI messages:**

```javascript
function formatWelcome(name, time) {
  const greeting = time < 12 ? "Good morning" : time < 18 ? "Good afternoon" : "Good evening";
  return `${greeting}, ${name}! Welcome back.`;
}

console.log(formatWelcome("Alice", 10)); // "Good morning, Alice! Welcome back."
console.log(formatWelcome("Bob", 14));   // "Good afternoon, Bob! Welcome back."
```

**Validate and clean input:**

```javascript
function cleanEmail(email) {
  return email.trim().toLowerCase();
}

console.log(cleanEmail("  ALICE@EXAMPLE.COM  ")); // "alice@example.com"

function isValidEmail(email) {
  return email.includes("@") && email.includes(".");
}

console.log(isValidEmail("user@example.com")); // true
console.log(isValidEmail("invalid-email"));    // false
```

**Parse CSV data:**

```javascript
const csvData = "Alice,25,alice@example.com\nBob,30,bob@example.com";

const users = csvData.split("\n").map(line => {
  const [name, age, email] = line.split(",");
  return { name, age: Number(age), email };
});

console.log(users);
// [
//   { name: "Alice", age: 25, email: "alice@example.com" },
//   { name: "Bob", age: 30, email: "bob@example.com" }
// ]
```

### Mini Exercise: Strings

**Challenge:** Write a function that capitalizes the first letter of each word in a sentence.

```javascript
// Example: "hello world" → "Hello World"
```

<details>
<summary>Solution</summary>

```javascript
function capitalizeWords(sentence) {
  return sentence
    .split(" ")
    .map(word => word[0].toUpperCase() + word.slice(1))
    .join(" ");
}

console.log(capitalizeWords("hello world")); // "Hello World"
console.log(capitalizeWords("javascript is fun")); // "Javascript Is Fun"
```
</details>

---

## Section 11: Null, Undefined, and Error Handling

### null vs undefined

```javascript
// undefined - JavaScript's way of saying "I don't know"
let x;
console.log(x); // undefined (declared but not assigned)

function doNothing() {
  // No return statement
}
console.log(doNothing()); // undefined

const obj = {};
console.log(obj.missing); // undefined (property doesn't exist)

// null - your way of saying "intentionally empty"
let data = null; // "I know there's no data yet"

// Later...
data = { name: "Alice" };
```

**When each appears:**

```javascript
// undefined appears when:
// 1. Variable declared but not assigned
let a;

// 2. Function doesn't return anything
function noReturn() {}

// 3. Accessing missing property
const obj = {};
obj.missing;

// 4. Function parameter not provided
function greet(name) {
  console.log(name); // undefined if not provided
}
greet();

// null is explicitly set by you:
let user = null; // Will fetch later
let error = null; // No error yet
```

### Guard Clauses: Defensive Programming

```javascript
function divide(a, b) {
  // Guard against division by zero
  if (b === 0) {
    return null; // Or throw error, or return message
  }
  return a / b;
}

console.log(divide(10, 2)); // 5
console.log(divide(10, 0)); // null

function getUserName(user) {
  // Guard against missing data
  if (!user) {
    return "Guest";
  }
  if (!user.name) {
    return "Anonymous";
  }
  return user.name;
}

console.log(getUserName(null));           // "Guest"
console.log(getUserName({}));            // "Anonymous"
console.log(getUserName({ name: "Alice" })); // "Alice"
```

### Optional Chaining (Modern JS)

```javascript
const user = {
  name: "Alice",
  address: {
    city: "Boston"
  }
};

// ❌ Without optional chaining - crashes if property missing
// console.log(user.address.street.number); // Error!

// ✅ Old way - check each level
if (user && user.address && user.address.street) {
  console.log(user.address.street.number);
}

// ✅ Modern way - optional chaining
console.log(user.address?.street?.number); // undefined (no error!)

// Works with methods too
console.log(user.greet?.()); // undefined if greet doesn't exist

// Works with arrays
const users = null;
console.log(users?.[0]?.name); // undefined (no error!)
```

### Nullish Coalescing (??)

```javascript
// ?? returns right side ONLY if left is null or undefined
const name = null ?? "Default";
console.log(name); // "Default"

const age = 0 ?? 18;
console.log(age); // 0 (because 0 is not null/undefined)

// Compare with || (OR operator)
const age1 = 0 || 18;
console.log(age1); // 18 (because 0 is falsy)

// Use ?? when 0, "", false are valid values
const count = 0 ?? 10;
console.log(count); // 0

const count2 = 0 || 10;
console.log(count2); // 10
```

### try...catch: Handling Errors

```javascript
// Basic try...catch
try {
  // Code that might throw an error
  const data = JSON.parse('invalid json');
} catch (error) {
  // Handle the error
  console.log("Oops! Something went wrong:", error.message);
}

console.log("Program continues..."); // Still runs!

// Without try...catch, program would crash:
// const data = JSON.parse('invalid json'); // ❌ Crashes entire program
```

**Real example: API call**

```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to fetch user:", error);
    return null; // Return safe default
  }
}
```

**Finally block:**

```javascript
try {
  console.log("Trying something...");
  throw new Error("Oops!");
} catch (error) {
  console.log("Caught error:", error.message);
} finally {
  console.log("This ALWAYS runs"); // Even if error caught
}
```

### Mini Exercise: Error Handling

**Challenge:** Write a safe function to get a deeply nested property with a default value.

<details>
<summary>Solution</summary>

```javascript
function getNestedValue(obj, path, defaultValue = null) {
  try {
    const keys = path.split(".");
    let result = obj;
    
    for (let key of keys) {
      result = result[key];
    }
    
    return result ?? defaultValue;
  } catch (error) {
    return defaultValue;
  }
}

const user = { profile: { name: "Alice", age: 25 } };

console.log(getNestedValue(user, "profile.name")); // "Alice"
console.log(getNestedValue(user, "profile.email", "N/A")); // "N/A"
console.log(getNestedValue(null, "anything", "Default")); // "Default"
```
</details>

---

Due to length limits, let me continue with the final sections in the next append...

## Section 12: Scope, Hoisting, and Closures

### Visual Scope Chain

```
Global Scope
│
├── Variable: globalVar = "I'm global"
│
└── Function: outer()
    │
    ├── Variable: outerVar = "I'm in outer"
    │
    └── Function: inner()
        │
        └── Variable: innerVar = "I'm in inner"
        
inner() can access: innerVar, outerVar, globalVar
outer() can access: outerVar, globalVar
Global can access: globalVar
```

**Code example:**

```javascript
const globalVar = "global";

function outer() {
  const outerVar = "outer";
  
  function inner() {
    const innerVar = "inner";
    
    // Can access all three
    console.log(innerVar);  // "inner"
    console.log(outerVar);  // "outer"
    console.log(globalVar); // "global"
  }
  
  inner();
  // console.log(innerVar); // ❌ Error: innerVar not accessible here
}

outer();
// console.log(outerVar); // ❌ Error: outerVar not accessible here
```

### Hoisting Explained

**Hoisting = JavaScript moves declarations to the top**

```javascript
// What you write:
console.log(x); // undefined (not an error!)
var x = 5;

// What JavaScript does (conceptually):
var x; // Declaration hoisted
console.log(x); // undefined
x = 5; // Assignment stays in place

// BUT let and const are NOT hoisted the same way:
// console.log(y); // ❌ Error: Cannot access before initialization
let y = 10;
```

**Function hoisting:**

```javascript
// Function declarations ARE hoisted
sayHi(); // Works!

function sayHi() {
  console.log("Hi!");
}

// Function expressions are NOT hoisted
// greet(); // ❌ Error

const greet = function() {
  console.log("Hello!");
};
```

### Closures: Functions That Remember

**Simple explanation:** A closure is when a function "remembers" variables from its outer scope, even after that outer function has finished.

```javascript
function makeCounter() {
  let count = 0; // Private variable
  
  return function() {
    count++; // Still has access to count!
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3

// count is not accessible outside
// console.log(count); // ❌ Error
```

**Visual diagram:**

```
makeCounter() runs:
│
├── Creates count = 0
├── Creates function
└── Returns function

Later, when you call counter():
│
└── Function still "remembers" count from makeCounter
    └── Increments it
```

**Real-world example: Private data**

```javascript
function createUser(name) {
  let password = "secret123"; // Private!
  
  return {
    getName() {
      return name;
    },
    checkPassword(input) {
      return input === password;
    },
    // No direct access to password!
  };
}

const user = createUser("Alice");
console.log(user.getName());           // "Alice"
console.log(user.checkPassword("wrong")); // false
console.log(user.checkPassword("secret123")); // true
// console.log(user.password); // undefined - can't access directly!
```

**Factory function pattern:**

```javascript
function createCalculator(startValue) {
  let total = startValue;
  
  return {
    add(num) {
      total += num;
      return total;
    },
    subtract(num) {
      total -= num;
      return total;
    },
    getTotal() {
      return total;
    }
  };
}

const calc1 = createCalculator(0);
console.log(calc1.add(10));      // 10
console.log(calc1.add(5));       // 15
console.log(calc1.subtract(3));  // 12

const calc2 = createCalculator(100);
console.log(calc2.add(50));      // 150
console.log(calc1.getTotal());   // 12 (separate from calc2!)
```

---

## Section 13: ES6+ Features for Beginners

### Spread Operator (...) for Arrays

```javascript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Combine arrays
const combined = [...arr1, ...arr2];
console.log(combined); // [1, 2, 3, 4, 5, 6]

// Copy array
const copy = [...arr1];
copy.push(4);
console.log(arr1); // [1, 2, 3] - original unchanged
console.log(copy); // [1, 2, 3, 4]

// Add items while copying
const extended = [0, ...arr1, 4, 5];
console.log(extended); // [0, 1, 2, 3, 4, 5]

// Math with arrays
const numbers = [5, 2, 8, 1, 9];
console.log(Math.max(...numbers)); // 9
```

### Spread Operator for Objects

```javascript
const user = { name: "Alice", age: 25 };
const location = { city: "Boston", country: "USA" };

// Combine objects
const profile = { ...user, ...location };
console.log(profile);
// { name: "Alice", age: 25, city: "Boston", country: "USA" }

// Copy object
const copy = { ...user };

// Override properties
const updated = { ...user, age: 26, email: "alice@example.com" };
console.log(updated);
// { name: "Alice", age: 26, email: "alice@example.com" }
```

**Critical for React:**

```javascript
// React state updates (immutable)
const [user, setUser] = useState({ name: "Alice", age: 25 });

// ❌ WRONG: Mutates state
user.age = 26;

// ✅ CORRECT: Creates new object
setUser({ ...user, age: 26 });
```

### Rest Parameters

```javascript
// Collect remaining arguments into array
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3));       // 6
console.log(sum(1, 2, 3, 4, 5)); // 15

// Mix with regular parameters
function introduce(greeting, ...names) {
  return `${greeting} ${names.join(", ")}!`;
}

console.log(introduce("Hello", "Alice", "Bob", "Carol"));
// "Hello Alice, Bob, Carol!"
```

### Array Destructuring

```javascript
const colors = ["red", "green", "blue"];

// Old way
const first = colors[0];
const second = colors[1];

// New way - destructuring
const [first, second, third] = colors;
console.log(first);  // "red"
console.log(second); // "green"
console.log(third);  // "blue"

// Skip elements
const [first, , third] = colors;
console.log(first); // "red"
console.log(third); // "blue"

// Rest in destructuring
const [first, ...rest] = colors;
console.log(first); // "red"
console.log(rest);  // ["green", "blue"]

// Default values
const [a, b, c, d = "yellow"] = colors;
console.log(d); // "yellow"
```

### Object Destructuring (Again, Super Important)

```javascript
const user = {
  name: "Alice",
  age: 25,
  email: "alice@example.com"
};

// Extract properties
const { name, age } = user;
console.log(name); // "Alice"
console.log(age);  // 25

// Rename while destructuring
const { name: userName, age: userAge } = user;
console.log(userName); // "Alice"

// Default values
const { name, age, phone = "N/A" } = user;
console.log(phone); // "N/A"

// Nested destructuring
const user = {
  name: "Alice",
  address: {
    city: "Boston",
    zip: "02101"
  }
};

const { address: { city, zip } } = user;
console.log(city); // "Boston"
```

### Destructuring in Function Parameters

```javascript
// Instead of this:
function greetUser(user) {
  return `Hello, ${user.name}! You're ${user.age} years old.`;
}

// Do this (React standard):
function greetUser({ name, age }) {
  return `Hello, ${name}! You're ${age} years old.`;
}

greetUser({ name: "Alice", age: 25 }); // "Hello, Alice! You're 25 years old."

// With defaults
function greetUser({ name = "Guest", age = 0 } = {}) {
  return `Hello, ${name}! You're ${age} years old.`;
}

greetUser(); // "Hello, Guest! You're 0 years old."
```

### Shorthand Properties

```javascript
const name = "Alice";
const age = 25;

// Old way
const user = {
  name: name,
  age: age
};

// New way (property shorthand)
const user = { name, age };
console.log(user); // { name: "Alice", age: 25 }

// Shorthand methods
const calculator = {
  // Old way
  add: function(a, b) {
    return a + b;
  },
  // New way
  subtract(a, b) {
    return a - b;
  }
};
```

### Arrow Functions Deep Dive

```javascript
// Traditional function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => {
  return a + b;
};

// Shorthand (implicit return)
const add = (a, b) => a + b;

// Single parameter (no parentheses needed)
const double = n => n * 2;

// No parameters (parentheses required)
const greet = () => "Hello!";

// Returning object (wrap in parentheses)
const makePerson = (name, age) => ({ name, age });
console.log(makePerson("Alice", 25)); // { name: "Alice", age: 25 }
```

**When NOT to use arrow functions:**

```javascript
// ❌ Methods that need 'this'
const user = {
  name: "Alice",
  greet: () => {
    console.log(`Hi, I'm ${this.name}`); // 'this' doesn't work here!
  }
};

// ✅ Use regular function
const user = {
  name: "Alice",
  greet() {
    console.log(`Hi, I'm ${this.name}`); // Works!
  }
};
```

---

## Section 14: Mini Real-World Challenges

### Challenge 1: Capitalize First Letter

**Problem:** Write a function that capitalizes the first letter of a string.

<details>
<summary>Solution</summary>

```javascript
function capitalize(str) {
  if (!str) return "";
  return str[0].toUpperCase() + str.slice(1);
}

console.log(capitalize("hello")); // "Hello"
console.log(capitalize("javascript")); // "Javascript"
```
</details>

### Challenge 2: Find Even Numbers

**Problem:** Return all even numbers from an array.

<details>
<summary>Solution</summary>

```javascript
function getEvens(numbers) {
  return numbers.filter(n => n % 2 === 0);
}

console.log(getEvens([1, 2, 3, 4, 5, 6])); // [2, 4, 6]
```
</details>

### Challenge 3: Sum Object Properties

**Problem:** Sum the `price` property from an array of objects.

<details>
<summary>Solution</summary>

```javascript
function sumPrices(products) {
  return products.reduce((total, product) => total + product.price, 0);
}

const products = [
  { name: "Laptop", price: 1000 },
  { name: "Mouse", price: 25 },
  { name: "Keyboard", price: 75 }
];

console.log(sumPrices(products)); // 1100
```
</details>

### Challenge 4: Validate Email

**Problem:** Check if a string is a valid email (contains @ and .).

<details>
<summary>Solution</summary>

```javascript
function isValidEmail(email) {
  return email.includes("@") && email.includes(".") && email.indexOf("@") < email.lastIndexOf(".");
}

console.log(isValidEmail("user@example.com")); // true
console.log(isValidEmail("invalid.com"));      // false
console.log(isValidEmail("@example.com"));     // false
```
</details>

### Challenge 5: Reverse a String

**Problem:** Reverse a string without using .reverse().

<details>
<summary>Solution</summary>

```javascript
// Method 1: Using built-in methods
function reverseString(str) {
  return str.split("").reverse().join("");
}

// Method 2: Manual loop
function reverseString(str) {
  let reversed = "";
  for (let i = str.length - 1; i >= 0; i--) {
    reversed += str[i];
  }
  return reversed;
}

console.log(reverseString("hello")); // "olleh"
```
</details>

### Challenge 6: Find Max Number

**Problem:** Find the maximum number in an array without using Math.max().

<details>
<summary>Solution</summary>

```javascript
function findMax(numbers) {
  let max = numbers[0];
  for (let num of numbers) {
    if (num > max) {
      max = num;
    }
  }
  return max;
}

// Or using reduce
function findMax(numbers) {
  return numbers.reduce((max, num) => num > max ? num : max);
}

console.log(findMax([3, 7, 2, 9, 1])); // 9
```
</details>

### Challenge 7: Remove Duplicates

**Problem:** Remove duplicate values from an array.

<details>
<summary>Solution</summary>

```javascript
// Method 1: Using Set (easiest)
function removeDuplicates(arr) {
  return [...new Set(arr)];
}

// Method 2: Using filter
function removeDuplicates(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
```
</details>

### Challenge 8: Count Vowels

**Problem:** Count the number of vowels in a string.

<details>
<summary>Solution</summary>

```javascript
function countVowels(str) {
  const vowels = "aeiouAEIOU";
  let count = 0;
  
  for (let char of str) {
    if (vowels.includes(char)) {
      count++;
    }
  }
  
  return count;
}

// Or using filter
function countVowels(str) {
  return str.split("").filter(char => "aeiouAEIOU".includes(char)).length;
}

console.log(countVowels("Hello World")); // 3
```
</details>

### Challenge 9: FizzBuzz

**Problem:** Print numbers 1-20, but for multiples of 3 print "Fizz", for multiples of 5 print "Buzz", for both print "FizzBuzz".

<details>
<summary>Solution</summary>

```javascript
function fizzBuzz(n) {
  for (let i = 1; i <= n; i++) {
    if (i % 15 === 0) {
      console.log("FizzBuzz");
    } else if (i % 3 === 0) {
      console.log("Fizz");
    } else if (i % 5 === 0) {
      console.log("Buzz");
    } else {
      console.log(i);
    }
  }
}

fizzBuzz(20);
```
</details>

### Challenge 10: Shopping Cart Total with Tax

**Problem:** Calculate total price with tax from a cart array.

<details>
<summary>Solution</summary>

```javascript
function calculateTotal(cart, taxRate = 0.08) {
  const subtotal = cart.reduce((sum, item) => {
    return sum + (item.price * item.quantity);
  }, 0);
  
  const tax = subtotal * taxRate;
  const total = subtotal + tax;
  
  return {
    subtotal: subtotal.toFixed(2),
    tax: tax.toFixed(2),
    total: total.toFixed(2)
  };
}

const cart = [
  { name: "Laptop", price: 1000, quantity: 1 },
  { name: "Mouse", price: 25, quantity: 2 },
  { name: "Keyboard", price: 75, quantity: 1 }
];

console.log(calculateTotal(cart));
// { subtotal: "1125.00", tax: "90.00", total: "1215.00" }
```
</details>

---

## Section 15: How All This Connects to React

### JavaScript Fundamentals = React Muscle Memory

Every React concept is just JavaScript:

```javascript
// 1. Components are FUNCTIONS
function Welcome() {
  return <h1>Hello!</h1>;
}

// 2. Props are OBJECTS (destructuring!)
function Welcome({ name, age }) {
  return <h1>Hello, {name}! You're {age}.</h1>;
}

// 3. State is VARIABLES
const [count, setCount] = useState(0);

// 4. Event handlers are CALLBACKS
<button onClick={() => setCount(count + 1)}>
  Click me
</button>

// 5. Rendering lists uses MAP
{todos.map(todo => (
  <li key={todo.id}>{todo.text}</li>
))}

// 6. Conditional rendering uses TERNARY/&&
{isLoggedIn ? <Dashboard /> : <Login />}
{error && <ErrorMessage />}

// 7. useEffect is for SIDE EFFECTS
useEffect(() => {
  // Fetch data, subscribe, etc.
}, [dependencies]);
```

### Complete React Example Using All JavaScript Concepts

```javascript
import { useState, useEffect } from 'react';

// Component = function
function TodoList() {
  // State = variables that trigger re-render
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState("");
  const [filter, setFilter] = useState("all");
  
  // useEffect = side effect (runs after render)
  useEffect(() => {
    // Fetch from API
    fetch('/api/todos')
      .then(res => res.json())
      .then(data => setTodos(data))
      .catch(error => console.error(error));
  }, []); // Empty array = run once on mount
  
  // Event handler = callback function
  const addTodo = () => {
    if (!input.trim()) return; // Guard clause
    
    const newTodo = {
      id: Date.now(),
      text: input,
      done: false
    };
    
    // Spread operator = immutable update
    setTodos([...todos, newTodo]);
    setInput(""); // Reset input
  };
  
  const toggleTodo = (id) => {
    // Map = transform array
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    ));
  };
  
  // Filter = get subset of array
  const filteredTodos = todos.filter(todo => {
    if (filter === "active") return !todo.done;
    if (filter === "completed") return todo.done;
    return true; // "all"
  });
  
  return (
    <div>
      <h1>Todos ({todos.length})</h1>
      
      {/* Controlled input */}
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === "Enter" && addTodo()}
      />
      <button onClick={addTodo}>Add</button>
      
      {/* Filter buttons */}
      <div>
        <button onClick={() => setFilter("all")}>All</button>
        <button onClick={() => setFilter("active")}>Active</button>
        <button onClick={() => setFilter("completed")}>Completed</button>
      </div>
      
      {/* Map = render list */}
      <ul>
        {filteredTodos.map(todo => (
          <li
            key={todo.id}
            onClick={() => toggleTodo(todo.id)}
            style={{ textDecoration: todo.done ? "line-through" : "none" }}
          >
            {todo.text}
          </li>
        ))}
      </ul>
      
      {/* Conditional rendering */}
      {filteredTodos.length === 0 && <p>No todos!</p>}
    </div>
  );
}
```

**JavaScript concepts used:**
- ✅ Functions (component, event handlers)
- ✅ Objects (todo items, props)
- ✅ Arrays (todos list)
- ✅ Array methods (map, filter)
- ✅ Destructuring (useState)
- ✅ Spread operator (immutable updates)
- ✅ Arrow functions (callbacks)
- ✅ Template literals (JSX)
- ✅ Conditional rendering (&&, ternary)
- ✅ String methods (trim)
- ✅ Guard clauses (input validation)

---

## Section 16: Muscle Memory & Learning Best Practices

### How to Practice Effectively

**1. Type, Don't Copy-Paste**

Your fingers need to learn the patterns. Copying doesn't build muscle memory.

```javascript
// Type this 10 times:
const double = (n) => n * 2;

// Then type variations:
const triple = (n) => n * 3;
const square = (n) => n * n;
```

**2. Explain Code Out Loud**

If you can't explain it, you don't understand it.

```javascript
// Read this code and explain each line out loud:
const users = [{ name: "Alice", age: 25 }, { name: "Bob", age: 30 }];
const names = users.map(user => user.name);

// "I'm declaring a constant called users that's an array of objects..."
// "Then I'm using map to transform the array..."
// "For each user object, I'm extracting just the name property..."
```

**3. Make Tiny Changes and Observe**

Don't just read code. Modify it and see what happens.

```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);

// Now try:
// - Change * 2 to * 3
// - Change map to filter
// - Add .filter(n => n > 5) before .map
```

**4. Read Error Messages Carefully**

Errors are teachers, not enemies.

```javascript
// TypeError: Cannot read property 'name' of undefined
// This means: you're trying to access .name on something that's undefined

// Solution: Check if it exists first
if (user) {
  console.log(user.name);
}
```

### Debugging Tips for Beginners

**1. console.log Everything**

```javascript
function calculateTotal(items) {
  console.log("Items:", items); // What did I receive?
  
  const total = items.reduce((sum, item) => {
    console.log("Sum so far:", sum, "Current item:", item);
    return sum + item.price;
  }, 0);
  
  console.log("Final total:", total); // What am I returning?
  return total;
}
```

**2. Change One Thing at a Time**

If code breaks, revert your last change. Isolate the problem.

**3. Simplify First**

If a complex function breaks, create a simpler version that works, then build up.

```javascript
// ❌ Complex version breaks
const result = data.filter(x => x.active).map(x => x.value).reduce((a, b) => a + b);

// ✅ Break it down
const active = data.filter(x => x.active);
console.log("Active:", active);

const values = active.map(x => x.value);
console.log("Values:", values);

const sum = values.reduce((a, b) => a + b);
console.log("Sum:", sum);

// Now you can see where it breaks!
```

### Learning Path

**Week 1-2: Basics**
- Variables, types, operators
- If/else, loops
- Functions
- Console.log everything!

**Week 3-4: Arrays & Objects**
- Array methods (map, filter, reduce)
- Object properties and methods
- Destructuring
- Build: Todo list (array of objects)

**Week 5-6: Advanced Concepts**
- Async/await
- ES6 features
- Closures (don't worry if confusing at first)
- Build: Fetch data from API

**Week 7-8: React Ready**
- Review all concepts
- Build 3 small projects
- Then start React!

### Encouragement

**It's okay to:**
- ✅ Feel confused (everyone does)
- ✅ Look things up constantly (senior devs do this daily)
- ✅ Reread sections multiple times
- ✅ Take breaks when frustrated
- ✅ Ask for help

**Remember:**
- 🎯 Mastery takes time, not talent
- 🎯 Small daily practice beats weekend marathons
- 🎯 Understanding > memorizing
- 🎯 Your past self would be amazed at what you know now

---

## Section 17: Quick Reference Cheatsheet

### Variables

```javascript
const name = "Alice";    // Can't reassign
let age = 25;           // Can reassign
// var score = 100;     // Avoid (old way)
```

### Data Types

```javascript
const num = 42;                    // Number
const str = "Hello";              // String
const bool = true;                // Boolean
const nothing = null;             // Null
const unknown = undefined;        // Undefined
const arr = [1, 2, 3];           // Array
const obj = { key: "value" };    // Object
```

### Operators

```javascript
// Arithmetic
+  -  *  /  %  **

// Assignment
=  +=  -=  *=  /=

// Comparison
===  !==  >  <  >=  <=

// Logical
&&  ||  !

// Ternary
condition ? ifTrue : ifFalse
```

### Control Flow

```javascript
// If/else
if (condition) {
} else if (anotherCondition) {
} else {
}

// Switch
switch (value) {
  case "a":
    break;
  default:
}

// Ternary
const result = condition ? "yes" : "no";
```

### Functions

```javascript
// Declaration
function name(params) { }

// Expression
const name = function(params) { };

// Arrow
const name = (params) => { };
const name = param => param * 2; // Implicit return
```

### Array Methods Cheat Sheet

```javascript
arr.push(item)           // Add to end
arr.pop()                // Remove from end
arr.unshift(item)        // Add to start
arr.shift()              // Remove from start
arr.includes(item)       // Check if exists
arr.indexOf(item)        // Find index
arr.slice(start, end)    // Get portion
arr.splice(start, count) // Remove items

// Transform
arr.map(fn)              // Transform each item
arr.filter(fn)           // Keep items that pass test
arr.find(fn)             // Get first match
arr.reduce(fn, initial)  // Combine into single value
arr.forEach(fn)          // Do something with each
```

### Object Methods

```javascript
Object.keys(obj)         // ["key1", "key2"]
Object.values(obj)       // [value1, value2]
Object.entries(obj)      // [["key1", val1], ["key2", val2]]
obj.hasOwnProperty(key)  // true/false
```

### String Methods

```javascript
str.length               // Length
str.toUpperCase()        // "HELLO"
str.toLowerCase()        // "hello"
str.includes(substr)     // true/false
str.indexOf(substr)      // Index or -1
str.slice(start, end)    // Extract portion
str.split(delimiter)     // String to array
str.replace(old, new)    // Replace text
str.trim()               // Remove whitespace
```

### Loops

```javascript
// For loop
for (let i = 0; i < arr.length; i++) { }

// For...of (arrays)
for (let item of arr) { }

// For...in (objects)
for (let key in obj) { }

// While
while (condition) { }

// Do while
do { } while (condition);
```

### ES6+ Syntax

```javascript
// Destructuring
const { name, age } = obj;
const [first, second] = arr;

// Spread
const copy = { ...obj };
const merged = [...arr1, ...arr2];

// Rest
function fn(...args) { }

// Template literals
`Hello, ${name}!`

// Arrow functions
const fn = (x) => x * 2;

// Default parameters
function fn(param = defaultValue) { }
```

### Common Patterns

```javascript
// Check if value exists
if (value) { }

// Default value
const result = value || defaultValue;
const result = value ?? defaultValue; // Nullish

// Optional chaining
user?.address?.city

// Array to unique values
[...new Set(arr)]

// Sum array
arr.reduce((sum, num) => sum + num, 0)

// Group by property
arr.reduce((groups, item) => {
  (groups[item.category] ||= []).push(item);
  return groups;
}, {})
```

---

## You Did It! 🎉

You now have a solid foundation in JavaScript. These aren't just syntax rules—they're the muscle memory that makes React feel natural.

**Next steps:**
1. Review sections that felt confusing
2. Do all the mini challenges again without looking at solutions
3. Build a small project using vanilla JavaScript
4. Then dive into React with confidence!

Remember: **Every React developer started exactly where you are now.** The difference between you and them is practice, not talent.

Keep typing. Keep experimenting. Keep building.

**You've got this.** 💪

---

**Ready for React?** [Continue to React Fundamentals →](/react-fundamentals/intro)

