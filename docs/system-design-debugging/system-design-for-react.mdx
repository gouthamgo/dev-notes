---
sidebar_position: 1
---

# Practical React System Design & Architecture

Many product companies, big brands, and senior technical interviews now ask system design and architecture questions for frontend roles—not just backend. This section gives you the prompts, diagrams, and model answers for React and web system design rounds.

**What you'll learn:**
- How to approach frontend system design questions
- Real architecture decisions with tradeoffs
- Folder structure and organization patterns
- State management choices
- Performance and scalability considerations

---

## Section 1: Design a Scalable E-Commerce React App

### The Prompt

**Interviewer:** "Design an e-commerce React application that supports:
- Product catalog browsing with categories
- Search functionality
- Shopping cart
- Checkout process
- User authentication

Explain your folder structure, state management choice, routing strategy, and key architectural decisions."

### How to Approach This

**Step 1: Clarifying Questions (ALWAYS ask these first!)**

Before jumping to solutions, ask:
- How many products? (Affects pagination strategy)
- Expected traffic? (Affects caching, code splitting)
- SEO important? (Affects SSR decision)
- Real-time inventory? (Affects state sync strategy)
- Mobile requirements? (Affects responsive design)
- Offline support needed? (Affects service workers)

**Step 2: High-Level Architecture**

```
┌─────────────────────────────────────────────┐
│           React Application                  │
├─────────────────────────────────────────────┤
│  Routing (React Router)                      │
│  ├─ / (Home)                                │
│  ├─ /products (Catalog)                     │
│  ├─ /product/:id (Product Details)          │
│  ├─ /cart (Shopping Cart)                   │
│  ├─ /checkout (Checkout Flow)               │
│  └─ /account (User Account)                 │
├─────────────────────────────────────────────┤
│  State Management                            │
│  ├─ Cart State (Context or Zustand)         │
│  ├─ User Auth (Context)                     │
│  └─ Product Data (React Query for caching)  │
├─────────────────────────────────────────────┤
│  API Layer                                   │
│  ├─ Product Service                         │
│  ├─ Cart Service                            │
│  ├─ Auth Service                            │
│  └─ Payment Service                         │
└─────────────────────────────────────────────┘
```

### Model Answer: Folder Structure

```
src/
├── components/
│   ├── common/
│   │   ├── Button.jsx
│   │   ├── Input.jsx
│   │   ├── Card.jsx
│   │   └── Modal.jsx
│   ├── layout/
│   │   ├── Header.jsx
│   │   ├── Footer.jsx
│   │   └── Sidebar.jsx
│   └── product/
│       ├── ProductCard.jsx
│       ├── ProductGrid.jsx
│       ├── ProductDetails.jsx
│       └── ProductFilters.jsx
├── pages/
│   ├── Home.jsx
│   ├── Products.jsx
│   ├── ProductDetail.jsx
│   ├── Cart.jsx
│   ├── Checkout.jsx
│   └── Account.jsx
├── hooks/
│   ├── useAuth.js
│   ├── useCart.js
│   ├── useProducts.js
│   └── useDebounce.js
├── context/
│   ├── AuthContext.jsx
│   └── CartContext.jsx
├── services/
│   ├── api.js (Axios instance)
│   ├── productService.js
│   ├── authService.js
│   └── cartService.js
├── utils/
│   ├── formatPrice.js
│   ├── validateForm.js
│   └── storage.js
├── routes/
│   ├── AppRoutes.jsx
│   └── ProtectedRoute.jsx
└── App.jsx
```

**Why this structure?**
- **Separation of concerns:** Components, business logic, API calls are separate
- **Reusability:** Common components can be shared
- **Scalability:** Easy to add new features without touching existing code
- **Testability:** Each layer can be tested independently

### State Management Decision

**The Question:** "Why Context for cart vs Redux vs Zustand?"

**Model Answer:**

```jsx
// Option 1: Context API (Good for small-medium apps)
// ✅ Pros: Built-in, no extra library, simple
// ❌ Cons: Can cause unnecessary re-renders, no devtools

const CartContext = createContext();

export function CartProvider({ children }) {
  const [items, setItems] = useState([]);
  
  const addItem = (product) => {
    setItems(prev => {
      const existing = prev.find(item => item.id === product.id);
      if (existing) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...prev, { ...product, quantity: 1 }];
    });
  };
  
  const removeItem = (id) => {
    setItems(prev => prev.filter(item => item.id !== id));
  };
  
  const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  
  return (
    <CartContext.Provider value={{ items, addItem, removeItem, total }}>
      {children}
    </CartContext.Provider>
  );
}
```

```javascript
// Option 2: Zustand (Recommended for medium-large apps)
// ✅ Pros: Minimal boilerplate, good performance, devtools
// ❌ Cons: Extra dependency (tiny though!)

import create from 'zustand';

export const useCartStore = create((set, get) => ({
  items: [],
  
  addItem: (product) => set(state => {
    const existing = state.items.find(item => item.id === product.id);
    if (existing) {
      return {
        items: state.items.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        )
      };
    }
    return { items: [...state.items, { ...product, quantity: 1 }] };
  }),
  
  removeItem: (id) => set(state => ({
    items: state.items.filter(item => item.id !== id)
  })),
  
  getTotal: () => {
    const items = get().items;
    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  }
}));
```

**My Recommendation for E-commerce:**
- **Cart state:** Zustand (needs to be accessed by many components, benefits from performance optimization)
- **Auth state:** Context (global, doesn't change often)
- **Product data:** React Query (handles caching, refetching, loading states automatically)

### Routing Strategy

```jsx
// routes/AppRoutes.jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import ProtectedRoute from './ProtectedRoute';

export default function AppRoutes() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Public routes */}
        <Route path="/" element={<Home />} />
        <Route path="/products" element={<Products />} />
        <Route path="/product/:id" element={<ProductDetail />} />
        <Route path="/cart" element={<Cart />} />
        
        {/* Protected routes (require login) */}
        <Route element={<ProtectedRoute />}>
          <Route path="/checkout" element={<Checkout />} />
          <Route path="/account" element={<Account />} />
          <Route path="/orders" element={<Orders />} />
        </Route>
        
        {/* Auth routes */}
        <Route path="/login" element={<Login />} />
        <Route path="/signup" element={<Signup />} />
        
        {/* 404 */}
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### Performance Optimizations

**1. Code Splitting (Lazy Loading)**

```jsx
import { lazy, Suspense } from 'react';

const Products = lazy(() => import('./pages/Products'));
const Checkout = lazy(() => import('./pages/Checkout'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/products" element={<Products />} />
        <Route path="/checkout" element={<Checkout />} />
      </Routes>
    </Suspense>
  );
}
```

**2. Image Optimization**

```jsx
// Use lazy loading for product images
<img
  src={product.thumbnail}
  data-src={product.fullImage}
  loading="lazy"
  alt={product.name}
/>
```

**3. Pagination/Infinite Scroll**

```jsx
// For catalog with thousands of products
function Products() {
  const [page, setPage] = useState(1);
  const { data, isLoading } = useQuery(
    ['products', page],
    () => fetchProducts(page)
  );
  
  // Implement infinite scroll or pagination UI
}
```

### Key Architectural Decisions & Tradeoffs

| Decision | Choice | Why | Tradeoff |
|----------|--------|-----|----------|
| **Framework** | React (CRA or Vite) | Component-based, huge ecosystem | Initial bundle size |
| **Routing** | React Router v6 | Industry standard, declarative | Client-side only (SEO concerns) |
| **State** | Zustand + React Query | Performance + caching | Learning curve |
| **Styling** | Tailwind CSS or CSS Modules | Utility-first or scoped | Large CSS bundle |
| **API calls** | Axios with React Query | Caching, retries, dev experience | Extra dependencies |
| **Forms** | React Hook Form | Performance, validation | Another library to learn |

---

## Section 2: How Would You Add Authentication?

### The Prompt

**Interviewer:** "Add a complete authentication system to this React app. Include login/logout, protected routes, token management, and role-based access control."

### Model Answer: Complete Auth System

**Step 1: Auth Context**

```jsx
// context/AuthContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import { authService } from '../services/authService';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Check for existing session on mount
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      authService.verifyToken(token)
        .then(userData => setUser(userData))
        .catch(() => localStorage.removeItem('token'))
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (email, password) => {
    const { user, token } = await authService.login(email, password);
    localStorage.setItem('token', token);
    setUser(user);
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const signup = async (email, password, name) => {
    const { user, token } = await authService.signup(email, password, name);
    localStorage.setItem('token', token);
    setUser(user);
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout, signup, loading }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
};
```

**Step 2: Protected Routes**

```jsx
// routes/ProtectedRoute.jsx
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function ProtectedRoute({ requiredRole }) {
  const { user, loading } = useAuth();
  
  if (loading) return <div>Loading...</div>;
  
  if (!user) {
    return <Navigate to="/login" replace />;
  }
  
  // Role-based access control
  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return <Outlet />;
}

// Usage
<Route element={<ProtectedRoute />}>
  <Route path="/checkout" element={<Checkout />} />
</Route>

<Route element={<ProtectedRoute requiredRole="admin" />}>
  <Route path="/admin" element={<Admin />} />
</Route>
```

**Step 3: API Interceptor (Auto-add auth token)**

```javascript
// services/api.js
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.REACT_APP_API_URL
});

// Add token to every request
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Handle 401 (unauthorized) responses
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

**Step 4: Login Component**

```jsx
// pages/Login.jsx
import { useState } from 'react';
import { useNavigate } from 'router-router-dom';
import { useAuth } from '../context/AuthContext';

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  
  const { login } = useAuth();
  const navigate = useNavigate();
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);
    
    try {
      await login(email, password);
      navigate('/'); // Redirect after successful login
    } catch (err) {
      setError(err.response?.data?.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <h2>Login</h2>
      
      {error && <div className="error">{error}</div>}
      
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      
      <input
        type="password"
        value={password}
        onChange={e => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}
```

### Security Considerations

**✅ DO:**
- Store JWT tokens in httpOnly cookies (if backend supports)
- Implement token refresh mechanism
- Use HTTPS in production
- Validate tokens on every request
- Implement rate limiting on login attempts
- Add CSRF protection

**❌ DON'T:**
- Store sensitive data in localStorage without encryption
- Trust client-side auth checks alone (always verify server-side)
- Include secrets in frontend code
- Use weak password validation

---

## Section 3: Design Patterns & Tradeoffs

### When to Lift State Up vs Context vs Global Store?

**Decision Matrix:**

```
Number of Components Accessing State
│
│   Too much prop drilling →
│   
│   Context or Global Store
│   ┌────────────────────────────┐
│   │                            │
│   │    Frequent updates?       │
│   │    ├─ Yes → Global Store   │
│   │    └─ No → Context         │
│   │                            │
│   └────────────────────────────┘
│
│   ← Just 2-3 components
│   
│   Lift State Up
└────────────────────────────────►
     Scope of State Usage
```

**1. Lift State Up** (2-3 components)

```jsx
// Good for: Parent and couple children sharing state
function Parent() {
  const [value, setValue] = useState(0);
  return (
    <>
      <ChildA value={value} onChange={setValue} />
      <ChildB value={value} />
    </>
  );
}
```

**2. Context** (Many components, infrequent updates)

```jsx
// Good for: Theme, user auth, language
const ThemeContext = createContext();

// Used across entire app, but doesn't change often
```

**3. Global Store** (Many components, frequent updates)

```jsx
// Good for: Shopping cart, complex forms, real-time data
import create from 'zustand';

const useStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 }))
}));
```

### SSR vs CSR vs SSG

**Client-Side Rendering (CRA, Vite)**
- ✅ Simple deployment, full interactivity
- ❌ SEO challenges, slower initial load
- **Use when:** Internal tools, dashboards, apps behind login

**Server-Side Rendering (Next.js)**
- ✅ Better SEO, faster perceived load
- ❌ More complex deployment, server costs
- **Use when:** E-commerce, blogs, marketing sites

**Static Site Generation (Next.js, Gatsby)**
- ✅ Best performance, cheap hosting
- ❌ Rebuild needed for updates
- **Use when:** Documentation, landing pages, blogs

### Code Splitting Strategies

```jsx
// Route-based (Most common)
const Dashboard = lazy(() => import('./Dashboard'));

// Component-based (For heavy components)
const Chart = lazy(() => import('./Chart'));

// Library-based (For large dependencies)
const moment = () => import('moment');
```

---

## Section 4: Take-Home Project Architecture

### The Assignment

**Company:** "Build a movie search app using TMDB API. Should have search, favorites, and detail pages. Due in 48 hours."

### How to Approach

**Hour 1-2: Planning**

1. **Read requirements 3 times**
2. **Sketch wireframes** on paper
3. **Plan folder structure**
4. **List features** (MVP first, nice-to-haves second)
5. **Set up repo** with good README

**Folder Structure for Take-Home:**

```
movie-app/
├── README.md (CRITICAL - explains your thinking!)
├── .env.example
├── src/
│   ├── components/
│   │   ├── MovieCard.jsx
│   │   ├── SearchBar.jsx
│   │   └── FavoriteButton.jsx
│   ├── pages/
│   │   ├── Search.jsx
│   │   ├── Details.jsx
│   │   └── Favorites.jsx
│   ├── hooks/
│   │   ├── useMovies.js
│   │   └── useFavorites.js
│   ├── services/
│   │   └── tmdbApi.js
│   └── App.jsx
└── package.json
```

### README Template for Take-Homes

```markdown
# Movie Search App

## 🎯 Overview
A React application for searching and favoriting movies using the TMDB API.

## ✨ Features
- [x] Search movies by title
- [x] View movie details
- [x] Add/remove favorites (persisted in localStorage)
- [x] Responsive design
- [x] Error handling
- [ ] Pagination (ran out of time, would add next)

## 🛠️ Tech Stack
- React 18
- React Router v6
- Axios for API calls
- Tailwind CSS for styling

## 🚀 Quick Start
\`\`\`bash
npm install
npm start
\`\`\`

## 🏗️ Architecture Decisions

### State Management
Used Context API for favorites because:
- Small scope (only favorites need global access)
- Infrequent updates
- No need for Redux overhead

### API Layer
Centralized all TMDB calls in tmdbApi.js:
- Easy to mock for testing
- Single source of truth for endpoints
- Error handling in one place

## 📝 Future Improvements
- Add unit tests (React Testing Library)
- Implement pagination
- Add movie trailer embeds
- PWA for offline support

## 📸 Screenshots
[Include 2-3 screenshots]

## ⏱️ Time Spent
- Planning & setup: 1 hour
- Core features: 4 hours
- Styling & polish: 2 hours
- README & deployment: 1 hour
**Total: ~8 hours**
```

### Deployment Checklist

**Before submitting:**

- [ ] Code runs with `npm start`
- [ ] No console errors
- [ ] Responsive on mobile
- [ ] Environment variables documented
- [ ] README is complete
- [ ] Deployed to Netlify/Vercel
- [ ] Live link in README
- [ ] Git history shows incremental progress (not one giant commit!)
- [ ] Code is formatted consistently

---

## Interview Tips for System Design

### What Interviewers Want to See

✅ **Clarifying questions** - Shows you don't jump to solutions  
✅ **Tradeoff discussions** - "I chose X over Y because..."  
✅ **Scalability thinking** - "If we had 10x users..."  
✅ **Real-world experience** - "In my last project, we..."  
✅ **Clean diagrams** - Draw architecture on whiteboard/screen  

### Common Follow-Up Questions

1. "How would you handle offline mode?"
2. "What if we needed real-time updates?"
3. "How would you optimize for slow networks?"
4. "How would you test this architecture?"
5. "What metrics would you track?"

### Resources to Study

- [React docs - Thinking in React](https://react.dev/learn/thinking-in-react)
- Frontend system design patterns
- Real company engineering blogs (Airbnb, Netflix React patterns)

---

**Next:** Learn how to debug the toughest React bugs in [Debugging Labs →](/system-design-debugging/debugging-labs)

