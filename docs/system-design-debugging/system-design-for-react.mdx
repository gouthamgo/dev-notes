---
sidebar_position: 1
---

# Practical React System Design & Architecture

Many product companies, big brands, and senior technical interviews now ask system design and architecture questions for frontend rolesâ€”not just backend. This section gives you the prompts, diagrams, and model answers for React and web system design rounds.

**What you'll learn:**
- How to approach frontend system design questions
- Real architecture decisions with tradeoffs
- Folder structure and organization patterns
- State management choices
- Performance and scalability considerations

---

## Section 1: Design a Scalable E-Commerce React App

### The Prompt

**Interviewer:** "Design an e-commerce React application that supports:
- Product catalog browsing with categories
- Search functionality
- Shopping cart
- Checkout process
- User authentication

Explain your folder structure, state management choice, routing strategy, and key architectural decisions."

### How to Approach This

**Step 1: Clarifying Questions (ALWAYS ask these first!)**

Before jumping to solutions, ask:
- How many products? (Affects pagination strategy)
- Expected traffic? (Affects caching, code splitting)
- SEO important? (Affects SSR decision)
- Real-time inventory? (Affects state sync strategy)
- Mobile requirements? (Affects responsive design)
- Offline support needed? (Affects service workers)

**Step 2: High-Level Architecture**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           React Application                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Routing (React Router)                      â”‚
â”‚  â”œâ”€ / (Home)                                â”‚
â”‚  â”œâ”€ /products (Catalog)                     â”‚
â”‚  â”œâ”€ /product/:id (Product Details)          â”‚
â”‚  â”œâ”€ /cart (Shopping Cart)                   â”‚
â”‚  â”œâ”€ /checkout (Checkout Flow)               â”‚
â”‚  â””â”€ /account (User Account)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  State Management                            â”‚
â”‚  â”œâ”€ Cart State (Context or Zustand)         â”‚
â”‚  â”œâ”€ User Auth (Context)                     â”‚
â”‚  â””â”€ Product Data (React Query for caching)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  API Layer                                   â”‚
â”‚  â”œâ”€ Product Service                         â”‚
â”‚  â”œâ”€ Cart Service                            â”‚
â”‚  â”œâ”€ Auth Service                            â”‚
â”‚  â””â”€ Payment Service                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Model Answer: Folder Structure

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ common/
â”‚   â”‚   â”œâ”€â”€ Button.jsx
â”‚   â”‚   â”œâ”€â”€ Input.jsx
â”‚   â”‚   â”œâ”€â”€ Card.jsx
â”‚   â”‚   â””â”€â”€ Modal.jsx
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ Header.jsx
â”‚   â”‚   â”œâ”€â”€ Footer.jsx
â”‚   â”‚   â””â”€â”€ Sidebar.jsx
â”‚   â””â”€â”€ product/
â”‚       â”œâ”€â”€ ProductCard.jsx
â”‚       â”œâ”€â”€ ProductGrid.jsx
â”‚       â”œâ”€â”€ ProductDetails.jsx
â”‚       â””â”€â”€ ProductFilters.jsx
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ Home.jsx
â”‚   â”œâ”€â”€ Products.jsx
â”‚   â”œâ”€â”€ ProductDetail.jsx
â”‚   â”œâ”€â”€ Cart.jsx
â”‚   â”œâ”€â”€ Checkout.jsx
â”‚   â””â”€â”€ Account.jsx
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useAuth.js
â”‚   â”œâ”€â”€ useCart.js
â”‚   â”œâ”€â”€ useProducts.js
â”‚   â””â”€â”€ useDebounce.js
â”œâ”€â”€ context/
â”‚   â”œâ”€â”€ AuthContext.jsx
â”‚   â””â”€â”€ CartContext.jsx
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ api.js (Axios instance)
â”‚   â”œâ”€â”€ productService.js
â”‚   â”œâ”€â”€ authService.js
â”‚   â””â”€â”€ cartService.js
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ formatPrice.js
â”‚   â”œâ”€â”€ validateForm.js
â”‚   â””â”€â”€ storage.js
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ AppRoutes.jsx
â”‚   â””â”€â”€ ProtectedRoute.jsx
â””â”€â”€ App.jsx
```

**Why this structure?**
- **Separation of concerns:** Components, business logic, API calls are separate
- **Reusability:** Common components can be shared
- **Scalability:** Easy to add new features without touching existing code
- **Testability:** Each layer can be tested independently

### State Management Decision

**The Question:** "Why Context for cart vs Redux vs Zustand?"

**Model Answer:**

```jsx
// Option 1: Context API (Good for small-medium apps)
// âœ… Pros: Built-in, no extra library, simple
// âŒ Cons: Can cause unnecessary re-renders, no devtools

const CartContext = createContext();

export function CartProvider({ children }) {
  const [items, setItems] = useState([]);
  
  const addItem = (product) => {
    setItems(prev => {
      const existing = prev.find(item => item.id === product.id);
      if (existing) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...prev, { ...product, quantity: 1 }];
    });
  };
  
  const removeItem = (id) => {
    setItems(prev => prev.filter(item => item.id !== id));
  };
  
  const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  
  return (
    <CartContext.Provider value={{ items, addItem, removeItem, total }}>
      {children}
    </CartContext.Provider>
  );
}
```

```javascript
// Option 2: Zustand (Recommended for medium-large apps)
// âœ… Pros: Minimal boilerplate, good performance, devtools
// âŒ Cons: Extra dependency (tiny though!)

import create from 'zustand';

export const useCartStore = create((set, get) => ({
  items: [],
  
  addItem: (product) => set(state => {
    const existing = state.items.find(item => item.id === product.id);
    if (existing) {
      return {
        items: state.items.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        )
      };
    }
    return { items: [...state.items, { ...product, quantity: 1 }] };
  }),
  
  removeItem: (id) => set(state => ({
    items: state.items.filter(item => item.id !== id)
  })),
  
  getTotal: () => {
    const items = get().items;
    return items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  }
}));
```

**My Recommendation for E-commerce:**
- **Cart state:** Zustand (needs to be accessed by many components, benefits from performance optimization)
- **Auth state:** Context (global, doesn't change often)
- **Product data:** React Query (handles caching, refetching, loading states automatically)

### Routing Strategy

```jsx
// routes/AppRoutes.jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import ProtectedRoute from './ProtectedRoute';

export default function AppRoutes() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Public routes */}
        <Route path="/" element={<Home />} />
        <Route path="/products" element={<Products />} />
        <Route path="/product/:id" element={<ProductDetail />} />
        <Route path="/cart" element={<Cart />} />
        
        {/* Protected routes (require login) */}
        <Route element={<ProtectedRoute />}>
          <Route path="/checkout" element={<Checkout />} />
          <Route path="/account" element={<Account />} />
          <Route path="/orders" element={<Orders />} />
        </Route>
        
        {/* Auth routes */}
        <Route path="/login" element={<Login />} />
        <Route path="/signup" element={<Signup />} />
        
        {/* 404 */}
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}
```

### Performance Optimizations

**1. Code Splitting (Lazy Loading)**

```jsx
import { lazy, Suspense } from 'react';

const Products = lazy(() => import('./pages/Products'));
const Checkout = lazy(() => import('./pages/Checkout'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/products" element={<Products />} />
        <Route path="/checkout" element={<Checkout />} />
      </Routes>
    </Suspense>
  );
}
```

**2. Image Optimization**

```jsx
// Use lazy loading for product images
<img
  src={product.thumbnail}
  data-src={product.fullImage}
  loading="lazy"
  alt={product.name}
/>
```

**3. Pagination/Infinite Scroll**

```jsx
// For catalog with thousands of products
function Products() {
  const [page, setPage] = useState(1);
  const { data, isLoading } = useQuery(
    ['products', page],
    () => fetchProducts(page)
  );
  
  // Implement infinite scroll or pagination UI
}
```

### Key Architectural Decisions & Tradeoffs

| Decision | Choice | Why | Tradeoff |
|----------|--------|-----|----------|
| **Framework** | React (CRA or Vite) | Component-based, huge ecosystem | Initial bundle size |
| **Routing** | React Router v6 | Industry standard, declarative | Client-side only (SEO concerns) |
| **State** | Zustand + React Query | Performance + caching | Learning curve |
| **Styling** | Tailwind CSS or CSS Modules | Utility-first or scoped | Large CSS bundle |
| **API calls** | Axios with React Query | Caching, retries, dev experience | Extra dependencies |
| **Forms** | React Hook Form | Performance, validation | Another library to learn |

---

## Section 2: How Would You Add Authentication?

### The Prompt

**Interviewer:** "Add a complete authentication system to this React app. Include login/logout, protected routes, token management, and role-based access control."

### Model Answer: Complete Auth System

**Step 1: Auth Context**

```jsx
// context/AuthContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import { authService } from '../services/authService';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  // Check for existing session on mount
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      authService.verifyToken(token)
        .then(userData => setUser(userData))
        .catch(() => localStorage.removeItem('token'))
        .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);
  
  const login = async (email, password) => {
    const { user, token } = await authService.login(email, password);
    localStorage.setItem('token', token);
    setUser(user);
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  const signup = async (email, password, name) => {
    const { user, token } = await authService.signup(email, password, name);
    localStorage.setItem('token', token);
    setUser(user);
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout, signup, loading }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
};
```

**Step 2: Protected Routes**

```jsx
// routes/ProtectedRoute.jsx
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function ProtectedRoute({ requiredRole }) {
  const { user, loading } = useAuth();
  
  if (loading) return <div>Loading...</div>;
  
  if (!user) {
    return <Navigate to="/login" replace />;
  }
  
  // Role-based access control
  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return <Outlet />;
}

// Usage
<Route element={<ProtectedRoute />}>
  <Route path="/checkout" element={<Checkout />} />
</Route>

<Route element={<ProtectedRoute requiredRole="admin" />}>
  <Route path="/admin" element={<Admin />} />
</Route>
```

**Step 3: API Interceptor (Auto-add auth token)**

```javascript
// services/api.js
import axios from 'axios';

const api = axios.create({
  baseURL: process.env.REACT_APP_API_URL
});

// Add token to every request
api.interceptors.request.use(config => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Handle 401 (unauthorized) responses
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

**Step 4: Login Component**

```jsx
// pages/Login.jsx
import { useState } from 'react';
import { useNavigate } from 'router-router-dom';
import { useAuth } from '../context/AuthContext';

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  
  const { login } = useAuth();
  const navigate = useNavigate();
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);
    
    try {
      await login(email, password);
      navigate('/'); // Redirect after successful login
    } catch (err) {
      setError(err.response?.data?.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <h2>Login</h2>
      
      {error && <div className="error">{error}</div>}
      
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
        placeholder="Email"
        required
      />
      
      <input
        type="password"
        value={password}
        onChange={e => setPassword(e.target.value)}
        placeholder="Password"
        required
      />
      
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}
```

### Security Considerations

**âœ… DO:**
- Store JWT tokens in httpOnly cookies (if backend supports)
- Implement token refresh mechanism
- Use HTTPS in production
- Validate tokens on every request
- Implement rate limiting on login attempts
- Add CSRF protection

**âŒ DON'T:**
- Store sensitive data in localStorage without encryption
- Trust client-side auth checks alone (always verify server-side)
- Include secrets in frontend code
- Use weak password validation

---

## Section 3: Design Patterns & Tradeoffs

### When to Lift State Up vs Context vs Global Store?

**Decision Matrix:**

```
Number of Components Accessing State
â”‚
â”‚   Too much prop drilling â†’
â”‚   
â”‚   Context or Global Store
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   â”‚                            â”‚
â”‚   â”‚    Frequent updates?       â”‚
â”‚   â”‚    â”œâ”€ Yes â†’ Global Store   â”‚
â”‚   â”‚    â””â”€ No â†’ Context         â”‚
â”‚   â”‚                            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”‚   â† Just 2-3 components
â”‚   
â”‚   Lift State Up
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
     Scope of State Usage
```

**1. Lift State Up** (2-3 components)

```jsx
// Good for: Parent and couple children sharing state
function Parent() {
  const [value, setValue] = useState(0);
  return (
    <>
      <ChildA value={value} onChange={setValue} />
      <ChildB value={value} />
    </>
  );
}
```

**2. Context** (Many components, infrequent updates)

```jsx
// Good for: Theme, user auth, language
const ThemeContext = createContext();

// Used across entire app, but doesn't change often
```

**3. Global Store** (Many components, frequent updates)

```jsx
// Good for: Shopping cart, complex forms, real-time data
import create from 'zustand';

const useStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 }))
}));
```

### SSR vs CSR vs SSG

**Client-Side Rendering (CRA, Vite)**
- âœ… Simple deployment, full interactivity
- âŒ SEO challenges, slower initial load
- **Use when:** Internal tools, dashboards, apps behind login

**Server-Side Rendering (Next.js)**
- âœ… Better SEO, faster perceived load
- âŒ More complex deployment, server costs
- **Use when:** E-commerce, blogs, marketing sites

**Static Site Generation (Next.js, Gatsby)**
- âœ… Best performance, cheap hosting
- âŒ Rebuild needed for updates
- **Use when:** Documentation, landing pages, blogs

### Code Splitting Strategies

```jsx
// Route-based (Most common)
const Dashboard = lazy(() => import('./Dashboard'));

// Component-based (For heavy components)
const Chart = lazy(() => import('./Chart'));

// Library-based (For large dependencies)
const moment = () => import('moment');
```

---

## Section 4: Take-Home Project Architecture

### The Assignment

**Company:** "Build a movie search app using TMDB API. Should have search, favorites, and detail pages. Due in 48 hours."

### How to Approach

**Hour 1-2: Planning**

1. **Read requirements 3 times**
2. **Sketch wireframes** on paper
3. **Plan folder structure**
4. **List features** (MVP first, nice-to-haves second)
5. **Set up repo** with good README

**Folder Structure for Take-Home:**

```
movie-app/
â”œâ”€â”€ README.md (CRITICAL - explains your thinking!)
â”œâ”€â”€ .env.example
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ MovieCard.jsx
â”‚   â”‚   â”œâ”€â”€ SearchBar.jsx
â”‚   â”‚   â””â”€â”€ FavoriteButton.jsx
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Search.jsx
â”‚   â”‚   â”œâ”€â”€ Details.jsx
â”‚   â”‚   â””â”€â”€ Favorites.jsx
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useMovies.js
â”‚   â”‚   â””â”€â”€ useFavorites.js
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ tmdbApi.js
â”‚   â””â”€â”€ App.jsx
â””â”€â”€ package.json
```

### README Template for Take-Homes

```markdown
# Movie Search App

## ğŸ¯ Overview
A React application for searching and favoriting movies using the TMDB API.

## âœ¨ Features
- [x] Search movies by title
- [x] View movie details
- [x] Add/remove favorites (persisted in localStorage)
- [x] Responsive design
- [x] Error handling
- [ ] Pagination (ran out of time, would add next)

## ğŸ› ï¸ Tech Stack
- React 18
- React Router v6
- Axios for API calls
- Tailwind CSS for styling

## ğŸš€ Quick Start
\`\`\`bash
npm install
npm start
\`\`\`

## ğŸ—ï¸ Architecture Decisions

### State Management
Used Context API for favorites because:
- Small scope (only favorites need global access)
- Infrequent updates
- No need for Redux overhead

### API Layer
Centralized all TMDB calls in tmdbApi.js:
- Easy to mock for testing
- Single source of truth for endpoints
- Error handling in one place

## ğŸ“ Future Improvements
- Add unit tests (React Testing Library)
- Implement pagination
- Add movie trailer embeds
- PWA for offline support

## ğŸ“¸ Screenshots
[Include 2-3 screenshots]

## â±ï¸ Time Spent
- Planning & setup: 1 hour
- Core features: 4 hours
- Styling & polish: 2 hours
- README & deployment: 1 hour
**Total: ~8 hours**
```

### Deployment Checklist

**Before submitting:**

- [ ] Code runs with `npm start`
- [ ] No console errors
- [ ] Responsive on mobile
- [ ] Environment variables documented
- [ ] README is complete
- [ ] Deployed to Netlify/Vercel
- [ ] Live link in README
- [ ] Git history shows incremental progress (not one giant commit!)
- [ ] Code is formatted consistently

---

## Interview Tips for System Design

### What Interviewers Want to See

âœ… **Clarifying questions** - Shows you don't jump to solutions  
âœ… **Tradeoff discussions** - "I chose X over Y because..."  
âœ… **Scalability thinking** - "If we had 10x users..."  
âœ… **Real-world experience** - "In my last project, we..."  
âœ… **Clean diagrams** - Draw architecture on whiteboard/screen  

### Common Follow-Up Questions

1. "How would you handle offline mode?"
2. "What if we needed real-time updates?"
3. "How would you optimize for slow networks?"
4. "How would you test this architecture?"
5. "What metrics would you track?"

### Resources to Study

- [React docs - Thinking in React](https://react.dev/learn/thinking-in-react)
- Frontend system design patterns
- Real company engineering blogs (Airbnb, Netflix React patterns)

---

**Next:** Learn how to debug the toughest React bugs in [Debugging Labs â†’](/system-design-debugging/debugging-labs)

